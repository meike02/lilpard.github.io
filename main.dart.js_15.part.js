// Generated by dart2js (NullSafetyMode.sound, trust primitives, omit checks, lax runtime type, deferred-serialization, csp), the Dart to JavaScript compiler version: 2.18.0-271.4.beta.
self.$__dart_deferred_initializers__ = self.$__dart_deferred_initializers__ || Object.create(null);
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var A = {SliverLogicalContainerParentData: function SliverLogicalContainerParentData(t0, t1) {
      this.ContainerParentDataMixin_previousSibling = t0;
      this.ContainerParentDataMixin_nextSibling = t1;
      this.layoutOffset = null;
    }, _SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin: function _SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin() {
    }, RenderSliverList: function RenderSliverList(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._childManager = t0;
      _._keepAliveBucket = t1;
      _.__RenderSliverMultiBoxAdaptor__debugDanglingKeepAlives_A = $;
      _._debugChildIntegrityEnabled = true;
      _.ContainerRenderObjectMixin__childCount = t2;
      _.ContainerRenderObjectMixin__firstChild = t3;
      _.ContainerRenderObjectMixin__lastChild = t4;
      _._geometry = null;
      _._object$_debugDisposed = false;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t5;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._depth = 0;
      _._node$_parent = _._node$_owner = null;
    }, RenderSliverList_performLayout_advance: function RenderSliverList_performLayout_advance(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.childConstraints = t2;
    }, RenderSliverPadding: function RenderSliverPadding(t0, t1, t2, t3) {
      var _ = this;
      _._sliver_padding$_resolvedPadding = null;
      _._sliver_padding$_padding = t0;
      _._sliver_padding$_textDirection = t1;
      _.RenderObjectWithChildMixin__child = t2;
      _._geometry = null;
      _._object$_debugDisposed = false;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t3;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._depth = 0;
      _._node$_parent = _._node$_owner = null;
    }, RenderShrinkWrappingViewport: function RenderShrinkWrappingViewport(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _.__RenderShrinkWrappingViewport__shrinkWrapExtent_A = _.__RenderShrinkWrappingViewport__maxScrollExtent_A = $;
      _._viewport$_hasVisualOverflow = false;
      _._viewport$_axisDirection = t0;
      _._crossAxisDirection = t1;
      _._viewport$_offset = t2;
      _._cacheExtent = t3;
      _._calculatedCacheExtent = null;
      _._cacheExtentStyle = t4;
      _._viewport$_clipBehavior = t5;
      _._viewport$_clipRectLayer = t6;
      _.ContainerRenderObjectMixin__childCount = t7;
      _.ContainerRenderObjectMixin__firstChild = t8;
      _.ContainerRenderObjectMixin__lastChild = t9;
      _._cachedDryLayoutSizes = _._cachedIntrinsicDimensions = null;
      _._computingThisDryLayout = false;
      _._cachedBaselines = _._size = null;
      _._debugActivePointers = 0;
      _._object$_debugDisposed = false;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t10;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._depth = 0;
      _._node$_parent = _._node$_owner = null;
    }, SliverPadding: function SliverPadding(t0, t1, t2) {
      this.padding = t0;
      this.child = t1;
      this.key = t2;
    },
    ListView$builder(itemBuilder, itemCount, physics, shrinkWrap) {
      var _null = null;
      return new A.ListView(new A.SliverChildBuilderDelegate(itemBuilder, itemCount, true, true, true, _null), _null, D.Axis_1, false, _null, _null, physics, true, _null, itemCount, D.DragStartBehavior_1, G.ScrollViewKeyboardDismissBehavior_0, _null, D.Clip_1, _null);
    },
    ScrollView: function ScrollView() {
    },
    ScrollView_build_closure: function ScrollView_build_closure(t0, t1, t2) {
      this.$this = t0;
      this.axisDirection = t1;
      this.slivers = t2;
    },
    ScrollView_build_closure0: function ScrollView_build_closure0(t0) {
      this.context = t0;
    },
    BoxScrollView: function BoxScrollView() {
    },
    ListView: function ListView(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) {
      var _ = this;
      _.childrenDelegate = t0;
      _.padding = t1;
      _.scrollDirection = t2;
      _.reverse = t3;
      _.controller = t4;
      _.primary = t5;
      _.physics = t6;
      _.shrinkWrap = t7;
      _.cacheExtent = t8;
      _.semanticChildCount = t9;
      _.dragStartBehavior = t10;
      _.keyboardDismissBehavior = t11;
      _.restorationId = t12;
      _.clipBehavior = t13;
      _.key = t14;
    },
    SliverChildBuilderDelegate: function SliverChildBuilderDelegate(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.builder = t0;
      _.childCount = t1;
      _.addAutomaticKeepAlives = t2;
      _.addRepaintBoundaries = t3;
      _.addSemanticIndexes = t4;
      _.findChildIndexCallback = t5;
    },
    SliverList: function SliverList(t0, t1) {
      this.delegate = t0;
      this.key = t1;
    },
    ShrinkWrappingViewport: function ShrinkWrappingViewport(t0, t1, t2, t3, t4) {
      var _ = this;
      _.axisDirection = t0;
      _.offset = t1;
      _.clipBehavior = t2;
      _.children = t3;
      _.key = t4;
    }
  },
  B, F, C, D, E, G, H;
  A = hunkHelpers.updateHolder(holdersList[19], A);
  B = holdersList[0];
  F = holdersList[33];
  C = holdersList[21];
  D = holdersList[2];
  E = holdersList[23];
  G = holdersList[34];
  H = holdersList[32];
  A.SliverLogicalContainerParentData.prototype = {};
  A._SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin.prototype = {
    detach$0(_) {
      this.super$ParentData$detach(0);
    }
  };
  A.RenderSliverList.prototype = {
    performLayout$0() {
      var t2, scrollOffset, targetEndScrollOffset, childConstraints, earliestUsefulChild, t3, t4, leadingChildrenWithoutLayoutOffset, t5, earliestScrollOffset, leadingChildWithLayout, firstChildScrollOffset, advance, leadingGarbage, extent, reachedEnd, trailingGarbage, child, estimatedMaxScrollOffset, t6, paintExtent, cacheExtent, _this = this, _null = null, _box_0 = {},
        constraints = type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(_this)),
        t1 = _this._childManager;
      t1._didUnderflow = false;
      t2 = constraints.scrollOffset;
      scrollOffset = t2 + constraints.cacheOrigin;
      targetEndScrollOffset = scrollOffset + constraints.remainingCacheExtent;
      childConstraints = constraints.asBoxConstraints$0();
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        if (!_this.addInitialChild$0()) {
          _this._geometry = F.SliverGeometry_yuB;
          t1.didFinishLayout$0();
          return;
        }
      _box_0.trailingChildWithLayout = null;
      earliestUsefulChild = _this.ContainerRenderObjectMixin__firstChild;
      t3 = earliestUsefulChild.parentData;
      t3.toString;
      t4 = type$.SliverMultiBoxAdaptorParentData;
      if (t4._as(t3).layoutOffset == null) {
        t3 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1");
        leadingChildrenWithoutLayoutOffset = 0;
        while (true) {
          if (earliestUsefulChild != null) {
            t5 = earliestUsefulChild.parentData;
            t5.toString;
            t5 = t4._as(t5).layoutOffset == null;
          } else
            t5 = false;
          if (!t5)
            break;
          t5 = earliestUsefulChild.parentData;
          t5.toString;
          earliestUsefulChild = t3._as(t5).ContainerParentDataMixin_nextSibling;
          ++leadingChildrenWithoutLayoutOffset;
        }
        _this.collectGarbage$2(leadingChildrenWithoutLayoutOffset, 0);
        if (_this.ContainerRenderObjectMixin__firstChild == null)
          if (!_this.addInitialChild$0()) {
            _this._geometry = F.SliverGeometry_yuB;
            t1.didFinishLayout$0();
            return;
          }
      }
      earliestUsefulChild = _this.ContainerRenderObjectMixin__firstChild;
      t3 = earliestUsefulChild.parentData;
      t3.toString;
      t3 = t4._as(t3).layoutOffset;
      t3.toString;
      earliestScrollOffset = t3;
      leadingChildWithLayout = _null;
      for (; earliestScrollOffset > scrollOffset; earliestScrollOffset = firstChildScrollOffset, leadingChildWithLayout = earliestUsefulChild) {
        earliestUsefulChild = _this.insertAndLayoutLeadingChild$2$parentUsesSize(childConstraints, true);
        if (earliestUsefulChild == null) {
          t3 = _this.ContainerRenderObjectMixin__firstChild;
          t5 = t3.parentData;
          t5.toString;
          t4._as(t5).layoutOffset = 0;
          if (scrollOffset === 0) {
            t3.layout$2$parentUsesSize(childConstraints, true);
            earliestUsefulChild = _this.ContainerRenderObjectMixin__firstChild;
            if (_box_0.trailingChildWithLayout == null)
              _box_0.trailingChildWithLayout = earliestUsefulChild;
            leadingChildWithLayout = earliestUsefulChild;
            break;
          } else {
            _this._geometry = C.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, -scrollOffset);
            return;
          }
        }
        t3 = _this.ContainerRenderObjectMixin__firstChild;
        t3.toString;
        firstChildScrollOffset = earliestScrollOffset - _this.paintExtentOf$1(t3);
        if (firstChildScrollOffset < -1e-10) {
          _this._geometry = C.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, -firstChildScrollOffset);
          t1 = _this.ContainerRenderObjectMixin__firstChild.parentData;
          t1.toString;
          t4._as(t1).layoutOffset = 0;
          return;
        }
        t3 = earliestUsefulChild.parentData;
        t3.toString;
        t4._as(t3).layoutOffset = firstChildScrollOffset;
        if (_box_0.trailingChildWithLayout == null)
          _box_0.trailingChildWithLayout = earliestUsefulChild;
      }
      if (scrollOffset < 1e-10)
        while (true) {
          t3 = _this.ContainerRenderObjectMixin__firstChild;
          t3.toString;
          t3 = t3.parentData;
          t3.toString;
          t4._as(t3);
          t5 = t3.index;
          t5.toString;
          if (!(t5 > 0))
            break;
          t3 = t3.layoutOffset;
          t3.toString;
          earliestUsefulChild = _this.insertAndLayoutLeadingChild$2$parentUsesSize(childConstraints, true);
          t5 = _this.ContainerRenderObjectMixin__firstChild;
          t5.toString;
          firstChildScrollOffset = t3 - _this.paintExtentOf$1(t5);
          t5 = _this.ContainerRenderObjectMixin__firstChild.parentData;
          t5.toString;
          t4._as(t5).layoutOffset = 0;
          if (firstChildScrollOffset < -1e-10) {
            _this._geometry = C.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, -firstChildScrollOffset);
            return;
          }
        }
      if (leadingChildWithLayout == null) {
        earliestUsefulChild.layout$2$parentUsesSize(childConstraints, true);
        _box_0.trailingChildWithLayout = earliestUsefulChild;
      }
      _box_0.inLayoutRange = true;
      _box_0.child = earliestUsefulChild;
      t3 = earliestUsefulChild.parentData;
      t3.toString;
      t4._as(t3);
      t5 = t3.index;
      t5.toString;
      _box_0.index = t5;
      t3 = t3.layoutOffset;
      t3.toString;
      _box_0.endScrollOffset = t3 + _this.paintExtentOf$1(earliestUsefulChild);
      advance = new A.RenderSliverList_performLayout_advance(_box_0, _this, childConstraints);
      for (leadingGarbage = 0; _box_0.endScrollOffset < scrollOffset;) {
        ++leadingGarbage;
        if (!advance.call$0()) {
          _this.collectGarbage$2(leadingGarbage - 1, 0);
          t1 = _this.ContainerRenderObjectMixin__lastChild;
          t2 = t1.parentData;
          t2.toString;
          t2 = t4._as(t2).layoutOffset;
          t2.toString;
          extent = t2 + _this.paintExtentOf$1(t1);
          _this._geometry = C.SliverGeometry$(_null, false, _null, _null, extent, 0, 0, extent, _null);
          return;
        }
      }
      while (true) {
        if (!(_box_0.endScrollOffset < targetEndScrollOffset)) {
          reachedEnd = false;
          break;
        }
        if (!advance.call$0()) {
          reachedEnd = true;
          break;
        }
      }
      t3 = _box_0.child;
      if (t3 != null) {
        t3 = t3.parentData;
        t3.toString;
        t5 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1");
        t3 = _box_0.child = t5._as(t3).ContainerParentDataMixin_nextSibling;
        for (trailingGarbage = 0; t3 != null; t3 = child) {
          ++trailingGarbage;
          t3 = t3.parentData;
          t3.toString;
          child = t5._as(t3).ContainerParentDataMixin_nextSibling;
          _box_0.child = child;
        }
      } else
        trailingGarbage = 0;
      _this.collectGarbage$2(leadingGarbage, trailingGarbage);
      estimatedMaxScrollOffset = _box_0.endScrollOffset;
      if (!reachedEnd) {
        t3 = _this.ContainerRenderObjectMixin__firstChild;
        t3.toString;
        t3 = t3.parentData;
        t3.toString;
        t4._as(t3);
        t5 = t3.index;
        t5.toString;
        t6 = _this.ContainerRenderObjectMixin__lastChild;
        t6.toString;
        t6 = t6.parentData;
        t6.toString;
        t6 = t4._as(t6).index;
        t6.toString;
        estimatedMaxScrollOffset = t1.estimateMaxScrollOffset$5$firstIndex$lastIndex$leadingScrollOffset$trailingScrollOffset(constraints, t5, t6, t3.layoutOffset, estimatedMaxScrollOffset);
      }
      t3 = _this.ContainerRenderObjectMixin__firstChild.parentData;
      t3.toString;
      t3 = t4._as(t3).layoutOffset;
      t3.toString;
      paintExtent = _this.calculatePaintOffset$3$from$to(constraints, t3, _box_0.endScrollOffset);
      t3 = _this.ContainerRenderObjectMixin__firstChild.parentData;
      t3.toString;
      t3 = t4._as(t3).layoutOffset;
      t3.toString;
      cacheExtent = _this.calculateCacheOffset$3$from$to(constraints, t3, _box_0.endScrollOffset);
      t3 = _box_0.endScrollOffset;
      _this._geometry = C.SliverGeometry$(cacheExtent, t3 > t2 + constraints.remainingPaintExtent || t2 > 0, _null, _null, estimatedMaxScrollOffset, paintExtent, 0, estimatedMaxScrollOffset, _null);
      if (estimatedMaxScrollOffset === t3)
        t1._didUnderflow = true;
      t1.didFinishLayout$0();
    }
  };
  A.RenderSliverPadding.prototype = {
    get$resolvedPadding() {
      return this._sliver_padding$_resolvedPadding;
    },
    _sliver_padding$_resolve$0() {
      if (this._sliver_padding$_resolvedPadding != null)
        return;
      this._sliver_padding$_resolvedPadding = this._sliver_padding$_padding;
    },
    set$padding(_, value) {
      var _this = this;
      if (_this._sliver_padding$_padding.$eq(0, value))
        return;
      _this._sliver_padding$_padding = value;
      _this._sliver_padding$_resolvedPadding = null;
      _this.markNeedsLayout$0();
    },
    set$textDirection(value) {
      var _this = this;
      if (_this._sliver_padding$_textDirection === value)
        return;
      _this._sliver_padding$_textDirection = value;
      _this._sliver_padding$_resolvedPadding = null;
      _this.markNeedsLayout$0();
    },
    performLayout$0() {
      this._sliver_padding$_resolve$0();
      this.super$RenderSliverEdgeInsetsPadding$performLayout();
    }
  };
  A.RenderShrinkWrappingViewport.prototype = {
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverLogicalContainerParentData))
        child.parentData = new A.SliverLogicalContainerParentData(null, null);
    },
    performLayout$0() {
      var mainAxisExtent, crossAxisExtent, t1, t2, t3, t4, t5, effectiveExtent, t6, t7, t8, t9, t10, correction, didAcceptViewportDimension, didAcceptContentDimension, _this = this,
        constraints = type$.BoxConstraints._as(B.RenderObject.prototype.get$constraints.call(_this));
      if (_this.ContainerRenderObjectMixin__firstChild == null) {
        switch (B.axisDirectionToAxis(_this._viewport$_axisDirection).index) {
          case 1:
            _this._size = new B.Size(constraints.maxWidth, constraints.minHeight);
            break;
          case 0:
            _this._size = new B.Size(constraints.minWidth, constraints.maxHeight);
            break;
        }
        _this._viewport$_offset.applyViewportDimension$1(0);
        _this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A = _this.__RenderShrinkWrappingViewport__maxScrollExtent_A = 0;
        _this._viewport$_hasVisualOverflow = false;
        _this._viewport$_offset.applyContentDimensions$2(0, 0);
        return;
      }
      switch (B.axisDirectionToAxis(_this._viewport$_axisDirection).index) {
        case 1:
          mainAxisExtent = constraints.maxHeight;
          crossAxisExtent = constraints.maxWidth;
          break;
        case 0:
          mainAxisExtent = constraints.maxWidth;
          crossAxisExtent = constraints.maxHeight;
          break;
        default:
          mainAxisExtent = null;
          crossAxisExtent = null;
      }
      t1 = _this.get$childAfter();
      t2 = constraints.minWidth;
      t3 = constraints.maxWidth;
      t4 = constraints.minHeight;
      t5 = constraints.maxHeight;
      effectiveExtent = null;
      do {
        t6 = _this._viewport$_offset._pixels;
        t6.toString;
        _this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A = _this.__RenderShrinkWrappingViewport__maxScrollExtent_A = 0;
        _this._viewport$_hasVisualOverflow = t6 < 0;
        switch (_this._cacheExtentStyle.index) {
          case 0:
            _this._calculatedCacheExtent = _this._cacheExtent;
            break;
          case 1:
            _this._calculatedCacheExtent = mainAxisExtent * _this._cacheExtent;
            break;
        }
        t7 = _this.ContainerRenderObjectMixin__firstChild;
        t8 = Math.max(0, t6);
        t9 = Math.min(0, t6);
        t6 = Math.max(0, -t6);
        t10 = _this._calculatedCacheExtent;
        t10.toString;
        correction = _this.layoutChildSequence$11$advance$cacheOrigin$child$crossAxisExtent$growthDirection$layoutOffset$mainAxisExtent$overlap$remainingCacheExtent$remainingPaintExtent$scrollOffset(t1, -t10, t7, crossAxisExtent, D.GrowthDirection_0, t6, mainAxisExtent, t9, mainAxisExtent + 2 * t10, mainAxisExtent + t9, t8);
        if (correction !== 0)
          _this._viewport$_offset.correctBy$1(correction);
        else {
          switch (B.axisDirectionToAxis(_this._viewport$_axisDirection).index) {
            case 1:
              effectiveExtent = B.clampDouble(_this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A, t4, t5);
              break;
            case 0:
              effectiveExtent = B.clampDouble(_this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A, t2, t3);
              break;
          }
          didAcceptViewportDimension = _this._viewport$_offset.applyViewportDimension$1(effectiveExtent);
          didAcceptContentDimension = _this._viewport$_offset.applyContentDimensions$2(0, Math.max(0, _this.__RenderShrinkWrappingViewport__maxScrollExtent_A - effectiveExtent));
          if (didAcceptViewportDimension && didAcceptContentDimension)
            break;
        }
      } while (true);
      switch (B.axisDirectionToAxis(_this._viewport$_axisDirection).index) {
        case 1:
          _this._size = new B.Size(B.clampDouble(crossAxisExtent, t2, t3), B.clampDouble(effectiveExtent, t4, t5));
          break;
        case 0:
          _this._size = new B.Size(B.clampDouble(effectiveExtent, t2, t3), B.clampDouble(crossAxisExtent, t4, t5));
          break;
      }
    },
    get$hasVisualOverflow() {
      return this._viewport$_hasVisualOverflow;
    },
    updateOutOfBandData$2(growthDirection, childLayoutGeometry) {
      var _this = this,
        t1 = _this.__RenderShrinkWrappingViewport__maxScrollExtent_A;
      t1 === $ && B.throwUnnamedLateFieldNI();
      _this.__RenderShrinkWrappingViewport__maxScrollExtent_A = t1 + childLayoutGeometry.scrollExtent;
      if (childLayoutGeometry.hasVisualOverflow)
        _this._viewport$_hasVisualOverflow = true;
      t1 = _this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A;
      t1 === $ && B.throwUnnamedLateFieldNI();
      _this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A = t1 + childLayoutGeometry.maxPaintExtent;
    },
    updateChildLayoutOffset$3(child, layoutOffset, growthDirection) {
      var t1 = child.parentData;
      t1.toString;
      type$.SliverLogicalParentData._as(t1).layoutOffset = layoutOffset;
    },
    paintOffsetOf$1(child) {
      var t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverLogicalParentData._as(t1).layoutOffset;
      t1.toString;
      return this.computeAbsolutePaintOffset$3(child, t1, D.GrowthDirection_0);
    },
    scrollOffsetOf$2(child, scrollOffsetWithinChild) {
      var t1, scrollOffsetToChild, t2,
        current = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1"), scrollOffsetToChild = 0; current !== child;) {
        scrollOffsetToChild += current._geometry.scrollExtent;
        t2 = current.parentData;
        t2.toString;
        current = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
      return scrollOffsetToChild + scrollOffsetWithinChild;
    },
    maxScrollObstructionExtentBefore$1(child) {
      var t1, t2,
        current = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1"); current !== child;) {
        current._geometry.toString;
        t2 = current.parentData;
        t2.toString;
        current = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
      return 0;
    },
    applyPaintTransform$2(child, transform) {
      var offset = this.paintOffsetOf$1(type$.RenderSliver._as(child));
      transform.translate$2(0, offset._dx, offset._dy);
    },
    computeChildMainAxisPosition$2(child, parentMainAxisPosition) {
      var t2,
        t1 = child.parentData;
      t1.toString;
      type$.SliverLogicalParentData._as(t1);
      t2 = type$.SliverConstraints;
      switch (B.applyGrowthDirectionToAxisDirection(t2._as(B.RenderObject.prototype.get$constraints.call(child)).axisDirection, t2._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection)) {
        case D.AxisDirection_2:
        case D.AxisDirection_1:
          t1 = t1.layoutOffset;
          t1.toString;
          return parentMainAxisPosition - t1;
        case D.AxisDirection_0:
          t2 = this._size._dy;
          t1 = t1.layoutOffset;
          t1.toString;
          return t2 - parentMainAxisPosition - t1;
        case D.AxisDirection_3:
          t2 = this._size._dx;
          t1 = t1.layoutOffset;
          t1.toString;
          return t2 - parentMainAxisPosition - t1;
      }
    },
    get$indexOfFirstChild() {
      return 0;
    },
    labelForChild$1(index) {
      return "child " + index;
    },
    get$childrenInPaintOrder() {
      var t1, t2,
        children = B._setArrayType([], type$.JSArray_RenderSliver),
        child = this.ContainerRenderObjectMixin__lastChild;
      for (t1 = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1"); child != null;) {
        children.push(child);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_previousSibling;
      }
      return children;
    },
    get$childrenInHitTestOrder() {
      var t1, t2,
        children = B._setArrayType([], type$.JSArray_RenderSliver),
        child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1"); child != null;) {
        children.push(child);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
      return children;
    }
  };
  A.SliverPadding.prototype = {
    createRenderObject$1(context) {
      var t1 = context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality);
      t1.toString;
      t1 = new A.RenderSliverPadding(this.padding, t1.textDirection, null, B.LayerHandle$(type$.ContainerLayer));
      t1.RenderObject$0();
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2(context, renderObject) {
      var t1;
      renderObject.set$padding(0, this.padding);
      t1 = context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality);
      t1.toString;
      renderObject.set$textDirection(t1.textDirection);
    }
  };
  A.ScrollView.prototype = {
    buildViewport$4(context, offset, axisDirection, slivers) {
      return new A.ShrinkWrappingViewport(axisDirection, offset, this.clipBehavior, slivers, null);
    },
    build$1(context) {
      var t1, mediaQueryHorizontalPadding, mediaQueryVerticalPadding, slivers, t2, effectivePrimary, scrollController, scrollable, scrollableResult, _this = this, _null = null,
        sliver = _this.buildChildLayout$1(context),
        effectivePadding = _this.padding,
        mediaQuery = B.MediaQuery_maybeOf(context);
      if (mediaQuery != null) {
        t1 = mediaQuery.padding;
        mediaQueryHorizontalPadding = t1.copyWith$2$bottom$top(0, 0);
        mediaQueryVerticalPadding = t1.copyWith$2$left$right(0, 0);
        t1 = _this.scrollDirection === D.Axis_1;
        effectivePadding = t1 ? mediaQueryVerticalPadding : mediaQueryHorizontalPadding;
        sliver = new B.MediaQuery(mediaQuery.copyWith$1$padding(t1 ? mediaQueryHorizontalPadding : mediaQueryVerticalPadding), sliver, _null);
      }
      slivers = B._setArrayType([effectivePadding != null ? new A.SliverPadding(effectivePadding, sliver, _null) : sliver], type$.JSArray_Widget);
      t1 = _this.scrollDirection;
      t2 = E.getAxisDirectionFromAxisReverseAndDirectionality(context, t1, false);
      effectivePrimary = _this.primary;
      effectivePrimary = E.PrimaryScrollController_shouldInherit(context, t1);
      scrollController = effectivePrimary ? B.PrimaryScrollController_of(context) : _this.controller;
      scrollable = E.Scrollable$(t2, _this.clipBehavior, scrollController, _this.dragStartBehavior, false, _this.physics, _this.restorationId, _null, _this.semanticChildCount, new A.ScrollView_build_closure(_this, t2, slivers));
      scrollableResult = effectivePrimary && scrollController != null ? E.PrimaryScrollController$none(scrollable) : scrollable;
      if (_this.keyboardDismissBehavior === G.ScrollViewKeyboardDismissBehavior_1)
        return new B.NotificationListener(new A.ScrollView_build_closure0(context), scrollableResult, _null, type$.NotificationListener_ScrollUpdateNotification);
      else
        return scrollableResult;
    }
  };
  A.BoxScrollView.prototype = {};
  A.ListView.prototype = {
    buildChildLayout$1(context) {
      return new A.SliverList(this.childrenDelegate, null);
    }
  };
  A.SliverChildBuilderDelegate.prototype = {
    findIndexByKey$1(key) {
      return null;
    },
    build$2(context, index) {
      var child, exception, stackTrace, t1, exception0, details, key, semanticIndex, _null = null;
      if (index >= 0)
        t1 = index >= this.childCount;
      else
        t1 = true;
      if (t1)
        return _null;
      child = null;
      try {
        child = this.builder.call$2(context, index);
      } catch (exception0) {
        exception = B.unwrapException(exception0);
        stackTrace = B.getTraceFromException(exception0);
        details = new B.FlutterErrorDetails(exception, stackTrace, "widgets library", B.ErrorDescription$("building"), _null, false);
        B.FlutterError_reportError(details);
        child = B.ErrorWidget__defaultErrorWidgetBuilder(details);
      }
      if (child == null)
        return _null;
      if (child.key != null) {
        t1 = child.key;
        t1.toString;
        key = new C._SaltedValueKey(t1);
      } else
        key = _null;
      t1 = child;
      child = new B.RepaintBoundary(t1, _null);
      semanticIndex = C._kDefaultSemanticIndexCallback(child, index);
      if (semanticIndex != null)
        child = new C.IndexedSemantics(semanticIndex, child, _null);
      t1 = child;
      child = new C.AutomaticKeepAlive(new C._SelectionKeepAlive(t1, _null), _null);
      return new B.KeyedSubtree(child, key);
    },
    get$estimatedChildCount() {
      return this.childCount;
    },
    shouldRebuild$1(oldDelegate) {
      return true;
    }
  };
  A.SliverList.prototype = {
    createElement$0(_) {
      return C.SliverMultiBoxAdaptorElement$(this, true);
    },
    createRenderObject$1(context) {
      var t1 = new A.RenderSliverList(type$.SliverMultiBoxAdaptorElement._as(context), B.LinkedHashMap_LinkedHashMap$_empty(type$.int, type$.RenderBox), 0, null, null, B.LayerHandle$(type$.ContainerLayer));
      t1.RenderObject$0();
      return t1;
    }
  };
  A.ShrinkWrappingViewport.prototype = {
    createRenderObject$1(context) {
      var t1 = this.axisDirection,
        t2 = C.Viewport_getDefaultCrossAxisDirection(context, t1),
        t3 = B.LayerHandle$(type$.ClipRectLayer);
      t1 = new A.RenderShrinkWrappingViewport(t1, t2, this.offset, 250, H.CacheExtentStyle_0, this.clipBehavior, t3, 0, null, null, B.LayerHandle$(type$.ContainerLayer));
      t1.RenderObject$0();
      t1.addAll$1(0, null);
      return t1;
    },
    updateRenderObject$2(context, renderObject) {
      var t1 = this.axisDirection;
      renderObject.set$axisDirection(t1);
      t1 = C.Viewport_getDefaultCrossAxisDirection(context, t1);
      renderObject.set$crossAxisDirection(t1);
      renderObject.set$offset(0, this.offset);
      renderObject.set$clipBehavior(this.clipBehavior);
    }
  };
  var typesOffset = hunkHelpers.updateTypes([]);
  A.RenderSliverList_performLayout_advance.prototype = {
    call$0() {
      var t4, child, t5,
        t1 = this._box_0,
        t2 = t1.child,
        t3 = t1.trailingChildWithLayout;
      if (t2 == t3)
        t1.inLayoutRange = false;
      t4 = this.$this;
      t2 = t2.parentData;
      t2.toString;
      child = t1.child = B._instanceType(t4)._eval$1("ContainerRenderObjectMixin.1")._as(t2).ContainerParentDataMixin_nextSibling;
      t2 = child == null;
      if (t2)
        t1.inLayoutRange = false;
      t5 = ++t1.index;
      if (!t1.inLayoutRange) {
        if (!t2) {
          t2 = child.parentData;
          t2.toString;
          t2 = type$.SliverMultiBoxAdaptorParentData._as(t2).index;
          t2.toString;
          t5 = t2 !== t5;
          t2 = t5;
        } else
          t2 = true;
        t5 = this.childConstraints;
        if (t2) {
          child = t4.insertAndLayoutChild$3$after$parentUsesSize(t5, t3, true);
          t1.child = child;
          if (child == null)
            return false;
        } else
          child.layout$2$parentUsesSize(t5, true);
        t2 = t1.trailingChildWithLayout = t1.child;
      } else
        t2 = child;
      t3 = t2.parentData;
      t3.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t3);
      t5 = t1.endScrollOffset;
      t3.layoutOffset = t5;
      t1.endScrollOffset = t5 + t4.paintExtentOf$1(t2);
      return true;
    },
    $signature: 70
  };
  A.ScrollView_build_closure.prototype = {
    call$2(context, offset) {
      return this.$this.buildViewport$4(context, offset, this.axisDirection, this.slivers);
    },
    $signature: 404
  };
  A.ScrollView_build_closure0.prototype = {
    call$1(notification) {
      var focusScope = B.FocusScope_of(this.context);
      if (notification.dragDetails != null && focusScope.get$hasFocus())
        focusScope.unfocus$0();
      return false;
    },
    $signature: 405
  };
  (function inheritance() {
    var _mixinHard = hunkHelpers.mixinHard,
      _inherit = hunkHelpers.inherit;
    _inherit(A._SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin, C.SliverLogicalParentData);
    _inherit(A.SliverLogicalContainerParentData, A._SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin);
    _inherit(A.RenderSliverList, C.RenderSliverMultiBoxAdaptor);
    _inherit(A.RenderSliverList_performLayout_advance, B.Closure0Args);
    _inherit(A.RenderSliverPadding, C.RenderSliverEdgeInsetsPadding);
    _inherit(A.RenderShrinkWrappingViewport, C.RenderViewportBase);
    _inherit(A.SliverPadding, B.SingleChildRenderObjectWidget);
    _inherit(A.ScrollView, B.StatelessWidget);
    _inherit(A.ScrollView_build_closure, B.Closure2Args);
    _inherit(A.ScrollView_build_closure0, B.Closure);
    _inherit(A.BoxScrollView, A.ScrollView);
    _inherit(A.ListView, A.BoxScrollView);
    _inherit(A.SliverChildBuilderDelegate, C.SliverChildDelegate);
    _inherit(A.SliverList, C.SliverMultiBoxAdaptorWidget);
    _inherit(A.ShrinkWrappingViewport, B.MultiChildRenderObjectWidget);
    _mixinHard(A._SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin, B.ContainerParentDataMixin);
  })();
  B._Universe_addRules(init.typeUniverse, JSON.parse('{"SliverLogicalContainerParentData":{"SliverLogicalParentData":[],"ContainerParentDataMixin":["RenderSliver"],"ParentData":[]},"RenderSliverList":{"RenderSliverMultiBoxAdaptor":[],"RenderSliver":[],"ContainerRenderObjectMixin":["RenderBox","SliverMultiBoxAdaptorParentData"],"RenderObject":[],"DiagnosticableTree":[],"AbstractNode":[],"HitTestTarget":[],"ContainerRenderObjectMixin.1":"SliverMultiBoxAdaptorParentData","ContainerRenderObjectMixin.0":"RenderBox"},"RenderSliverPadding":{"RenderSliver":[],"RenderObjectWithChildMixin":["RenderSliver"],"RenderObject":[],"DiagnosticableTree":[],"AbstractNode":[],"HitTestTarget":[]},"RenderShrinkWrappingViewport":{"_RenderViewportBase_RenderBox_ContainerRenderObjectMixin":["SliverLogicalContainerParentData"],"RenderBox":[],"ContainerRenderObjectMixin":["RenderSliver","SliverLogicalContainerParentData"],"RenderAbstractViewport":[],"RenderObject":[],"DiagnosticableTree":[],"AbstractNode":[],"HitTestTarget":[],"ContainerRenderObjectMixin.1":"SliverLogicalContainerParentData","_RenderViewportBase_RenderBox_ContainerRenderObjectMixin.0":"SliverLogicalContainerParentData","ContainerRenderObjectMixin.0":"RenderSliver"},"SliverPadding":{"SingleChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"ScrollView":{"StatelessWidget":[],"Widget":[],"DiagnosticableTree":[]},"BoxScrollView":{"StatelessWidget":[],"Widget":[],"DiagnosticableTree":[]},"ListView":{"StatelessWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverList":{"SliverMultiBoxAdaptorWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"ShrinkWrappingViewport":{"MultiChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]}}'));
  var type$ = (function rtii() {
    var findType = B.findType;
    return {
      BoxConstraints: findType("BoxConstraints"),
      ClipRectLayer: findType("ClipRectLayer"),
      ContainerLayer: findType("ContainerLayer0"),
      Directionality: findType("Directionality"),
      JSArray_RenderSliver: findType("JSArray<RenderSliver>"),
      JSArray_Widget: findType("JSArray<Widget>"),
      NotificationListener_ScrollUpdateNotification: findType("NotificationListener<ScrollUpdateNotification>"),
      RenderBox: findType("RenderBox"),
      RenderSliver: findType("RenderSliver"),
      SliverConstraints: findType("SliverConstraints"),
      SliverLogicalParentData: findType("SliverLogicalParentData"),
      SliverMultiBoxAdaptorElement: findType("SliverMultiBoxAdaptorElement"),
      SliverMultiBoxAdaptorParentData: findType("SliverMultiBoxAdaptorParentData"),
      int: findType("int")
    };
  })();
  (function constants() {
    F.SliverGeometry_yuB = new C.SliverGeometry(0, 0, 0, 0, 0, 0, false, false, null, 0);
  })();
};

$__dart_deferred_initializers__["B/nz9R0mezsVyBCR3IxFG7N+Bms="] = $__dart_deferred_initializers__.current
