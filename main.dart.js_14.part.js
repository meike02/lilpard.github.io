// Generated by dart2js (NullSafetyMode.sound, trust primitives, omit checks, lax runtime type, deferred-serialization, csp), the Dart to JavaScript compiler version: 2.18.0-271.4.beta.
self.$__dart_deferred_initializers__ = self.$__dart_deferred_initializers__ || Object.create(null);
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var A = {RenderIndexedSemantics: function RenderIndexedSemantics(t0, t1, t2) {
      var _ = this;
      _._proxy_box$_index = t0;
      _.RenderObjectWithChildMixin__child = t1;
      _._cachedDryLayoutSizes = _._cachedIntrinsicDimensions = null;
      _._computingThisDryLayout = false;
      _._cachedBaselines = _._size = null;
      _._debugActivePointers = 0;
      _._object$_debugDisposed = false;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t2;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    applyGrowthDirectionToScrollDirection(scrollDirection, growthDirection) {
      switch (growthDirection.index) {
        case 0:
          return scrollDirection;
        case 1:
          return A.flipScrollDirection(scrollDirection);
      }
    },
    SliverGeometry$(cacheExtent, hasVisualOverflow, hitTestExtent, layoutExtent, maxPaintExtent, paintExtent, paintOrigin, scrollExtent, scrollOffsetCorrection) {
      var t1 = layoutExtent == null ? paintExtent : layoutExtent,
        t2 = hitTestExtent == null ? paintExtent : hitTestExtent,
        t3 = cacheExtent == null ? layoutExtent : cacheExtent;
      if (t3 == null)
        t3 = paintExtent;
      return new A.SliverGeometry(scrollExtent, paintOrigin, paintExtent, t1, maxPaintExtent, t2, paintExtent > 0, hasVisualOverflow, scrollOffsetCorrection, t3);
    },
    SliverConstraints: function SliverConstraints(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.axisDirection = t0;
      _.growthDirection = t1;
      _.userScrollDirection = t2;
      _.scrollOffset = t3;
      _.precedingScrollExtent = t4;
      _.overlap = t5;
      _.remainingPaintExtent = t6;
      _.crossAxisExtent = t7;
      _.crossAxisDirection = t8;
      _.viewportMainAxisExtent = t9;
      _.cacheOrigin = t10;
      _.remainingCacheExtent = t11;
    },
    SliverGeometry: function SliverGeometry(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.scrollExtent = t0;
      _.paintOrigin = t1;
      _.paintExtent = t2;
      _.layoutExtent = t3;
      _.maxPaintExtent = t4;
      _.hitTestExtent = t5;
      _.visible = t6;
      _.hasVisualOverflow = t7;
      _.scrollOffsetCorrection = t8;
      _.cacheExtent = t9;
    },
    SliverHitTestResult: function SliverHitTestResult(t0, t1, t2) {
      this._path = t0;
      this._transforms = t1;
      this._localTransforms = t2;
    },
    SliverHitTestEntry: function SliverHitTestEntry(t0, t1, t2) {
      var _ = this;
      _.mainAxisPosition = t0;
      _.crossAxisPosition = t1;
      _.target = t2;
      _._transform = null;
    },
    SliverLogicalParentData: function SliverLogicalParentData() {
    },
    SliverPhysicalParentData: function SliverPhysicalParentData(t0) {
      this.paintOffset = t0;
    },
    SliverPhysicalContainerParentData: function SliverPhysicalContainerParentData(t0, t1, t2) {
      this.ContainerParentDataMixin_previousSibling = t0;
      this.ContainerParentDataMixin_nextSibling = t1;
      this.paintOffset = t2;
    },
    RenderSliver: function RenderSliver() {
    },
    RenderSliverHelpers: function RenderSliverHelpers() {
    },
    RenderSliverHelpers_hitTestBoxChild_closure: function RenderSliverHelpers_hitTestBoxChild_closure(t0, t1) {
      this._box_0 = t0;
      this.child = t1;
    },
    _SliverGeometry_Object_Diagnosticable: function _SliverGeometry_Object_Diagnosticable() {
    },
    _SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin: function _SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin() {
    },
    RenderSliverFixedExtentBoxAdaptor: function RenderSliverFixedExtentBoxAdaptor() {
    },
    KeepAliveParentDataMixin: function KeepAliveParentDataMixin() {
    },
    RenderSliverWithKeepAliveMixin: function RenderSliverWithKeepAliveMixin() {
    },
    SliverMultiBoxAdaptorParentData: function SliverMultiBoxAdaptorParentData(t0, t1, t2) {
      var _ = this;
      _.index = null;
      _._keptAlive = false;
      _.KeepAliveParentDataMixin_keepAlive = t0;
      _.ContainerParentDataMixin_previousSibling = t1;
      _.ContainerParentDataMixin_nextSibling = t2;
      _.layoutOffset = null;
    },
    RenderSliverMultiBoxAdaptor: function RenderSliverMultiBoxAdaptor() {
    },
    RenderSliverMultiBoxAdaptor__createOrObtainChild_closure: function RenderSliverMultiBoxAdaptor__createOrObtainChild_closure(t0, t1, t2) {
      this.$this = t0;
      this.index = t1;
      this.after = t2;
    },
    RenderSliverMultiBoxAdaptor_collectGarbage_closure: function RenderSliverMultiBoxAdaptor_collectGarbage_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderSliverMultiBoxAdaptor_collectGarbage__closure: function RenderSliverMultiBoxAdaptor_collectGarbage__closure() {
    },
    _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin: function _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin() {
    },
    _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers: function _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers() {
    },
    _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin: function _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin() {
    },
    _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin: function _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin() {
    },
    _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin: function _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin() {
    },
    RenderSliverEdgeInsetsPadding: function RenderSliverEdgeInsetsPadding() {
    },
    _RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin: function _RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin() {
    },
    CacheExtentStyle: function CacheExtentStyle(t0, t1) {
      this.index = t0;
      this._core$_name = t1;
    },
    RenderViewportBase: function RenderViewportBase() {
    },
    RenderViewportBase_visitChildrenForSemantics_closure: function RenderViewportBase_visitChildrenForSemantics_closure() {
    },
    RenderViewportBase_hitTestChildren_closure: function RenderViewportBase_hitTestChildren_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.child = t2;
      _.sliverResult = t3;
    },
    RenderViewport: function RenderViewport(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _._anchor = t0;
      _._center = null;
      _.__RenderViewport__maxScrollExtent_A = _.__RenderViewport__minScrollExtent_A = $;
      _._viewport$_hasVisualOverflow = false;
      _._viewport$_axisDirection = t1;
      _._crossAxisDirection = t2;
      _._viewport$_offset = t3;
      _._cacheExtent = t4;
      _._calculatedCacheExtent = null;
      _._cacheExtentStyle = t5;
      _._viewport$_clipBehavior = t6;
      _._viewport$_clipRectLayer = t7;
      _.ContainerRenderObjectMixin__childCount = t8;
      _.ContainerRenderObjectMixin__firstChild = t9;
      _.ContainerRenderObjectMixin__lastChild = t10;
      _._cachedDryLayoutSizes = _._cachedIntrinsicDimensions = null;
      _._computingThisDryLayout = false;
      _._cachedBaselines = _._size = null;
      _._debugActivePointers = 0;
      _._object$_debugDisposed = false;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t11;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _RenderViewportBase_RenderBox_ContainerRenderObjectMixin: function _RenderViewportBase_RenderBox_ContainerRenderObjectMixin() {
    },
    AutomaticKeepAlive: function AutomaticKeepAlive(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    _AutomaticKeepAliveState: function _AutomaticKeepAliveState(t0) {
      var _ = this;
      _._handles = null;
      _.___AutomaticKeepAliveState__child_A = $;
      _._keepingAlive = false;
      _._widget = null;
      _._debugLifecycleState = t0;
      _._framework$_element = null;
    },
    _AutomaticKeepAliveState__addClient_closure: function _AutomaticKeepAliveState__addClient_closure(t0) {
      this.$this = t0;
    },
    _AutomaticKeepAliveState__getChildElement_closure: function _AutomaticKeepAliveState__getChildElement_closure(t0) {
      this._box_0 = t0;
    },
    _AutomaticKeepAliveState__createCallback_closure: function _AutomaticKeepAliveState__createCallback_closure(t0, t1) {
      this.$this = t0;
      this.handle = t1;
    },
    _AutomaticKeepAliveState__createCallback__closure: function _AutomaticKeepAliveState__createCallback__closure(t0) {
      this.$this = t0;
    },
    _AutomaticKeepAliveState__createCallback__closure0: function _AutomaticKeepAliveState__createCallback__closure0(t0) {
      this.$this = t0;
    },
    _AutomaticKeepAliveState__createCallback___closure: function _AutomaticKeepAliveState__createCallback___closure(t0) {
      this.$this = t0;
    },
    IndexedSemantics: function IndexedSemantics(t0, t1, t2) {
      this.index = t0;
      this.child = t1;
      this.key = t2;
    },
    NeverScrollableScrollPhysics: function NeverScrollableScrollPhysics(t0) {
      this.parent = t0;
    },
    _kDefaultSemanticIndexCallback(_, localIndex) {
      return localIndex;
    },
    SliverMultiBoxAdaptorElement$(widget, replaceMovedChildren) {
      return new A.SliverMultiBoxAdaptorElement(replaceMovedChildren, D.SplayTreeMap$(type$.int, type$.nullable_Element), widget, C._ElementLifecycle_0);
    },
    SliverMultiBoxAdaptorElement__extrapolateMaxScrollOffset(firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset, childCount) {
      if (lastIndex === childCount - 1)
        return trailingScrollOffset;
      return trailingScrollOffset + (trailingScrollOffset - leadingScrollOffset) / (lastIndex - firstIndex + 1) * (childCount - lastIndex - 1);
    },
    KeepAlive$(child, keepAlive) {
      return new A.KeepAlive(keepAlive, child, null);
    },
    SliverChildDelegate: function SliverChildDelegate() {
    },
    _SaltedValueKey: function _SaltedValueKey(t0) {
      this.value = t0;
    },
    _SelectionKeepAlive: function _SelectionKeepAlive(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    _SelectionKeepAliveState: function _SelectionKeepAliveState(t0, t1) {
      var _ = this;
      _._sliver$_registrar = _._selectableAttachments = _._selectablesWithSelections = null;
      _._wantKeepAlive = false;
      _.AutomaticKeepAliveClientMixin__keepAliveHandle = t0;
      _._widget = null;
      _._debugLifecycleState = t1;
      _._framework$_element = null;
    },
    _SelectionKeepAliveState_listensTo_closure: function _SelectionKeepAliveState_listensTo_closure(t0, t1) {
      this.$this = t0;
      this.selectable = t1;
    },
    SliverWithKeepAliveWidget: function SliverWithKeepAliveWidget() {
    },
    SliverMultiBoxAdaptorWidget: function SliverMultiBoxAdaptorWidget() {
    },
    SliverMultiBoxAdaptorElement: function SliverMultiBoxAdaptorElement(t0, t1, t2, t3) {
      var _ = this;
      _._replaceMovedChildren = t0;
      _._childElements = t1;
      _._currentlyUpdatingChildIndex = _._currentBeforeChild = null;
      _._didUnderflow = false;
      _._slot = _._notificationTree = _._debugReassembleConfig = _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = null;
      _.__Element__depth_A = $;
      _._widget = t2;
      _._owner = null;
      _._lifecycleState = t3;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    },
    SliverMultiBoxAdaptorElement_performRebuild_processElement: function SliverMultiBoxAdaptorElement_performRebuild_processElement(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.newChildren = t2;
      _.adaptorWidget = t3;
      _.indexToLayoutOffset = t4;
    },
    SliverMultiBoxAdaptorElement_performRebuild_closure: function SliverMultiBoxAdaptorElement_performRebuild_closure() {
    },
    SliverMultiBoxAdaptorElement_performRebuild_closure0: function SliverMultiBoxAdaptorElement_performRebuild_closure0(t0, t1) {
      this.$this = t0;
      this.index = t1;
    },
    SliverMultiBoxAdaptorElement_createChild_closure: function SliverMultiBoxAdaptorElement_createChild_closure(t0, t1, t2) {
      this.$this = t0;
      this.after = t1;
      this.index = t2;
    },
    SliverMultiBoxAdaptorElement_removeChild_closure: function SliverMultiBoxAdaptorElement_removeChild_closure(t0, t1) {
      this.$this = t0;
      this.index = t1;
    },
    KeepAlive: function KeepAlive(t0, t1, t2) {
      this.keepAlive = t0;
      this.child = t1;
      this.key = t2;
    },
    __SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin: function __SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin() {
    },
    Viewport$(anchor, axisDirection, cacheExtent, cacheExtentStyle, center, clipBehavior, offset, slivers) {
      return new A.Viewport(axisDirection, anchor, offset, center, cacheExtent, cacheExtentStyle, clipBehavior, slivers, null);
    },
    Viewport_getDefaultCrossAxisDirection(context, axisDirection) {
      var t1;
      switch (axisDirection.index) {
        case 0:
          t1 = context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality);
          t1.toString;
          return D.textDirectionToAxisDirection(t1.textDirection);
        case 1:
          return C.AxisDirection_2;
        case 2:
          t1 = context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality);
          t1.toString;
          return D.textDirectionToAxisDirection(t1.textDirection);
        case 3:
          return C.AxisDirection_2;
      }
    },
    Viewport: function Viewport(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.axisDirection = t0;
      _.anchor = t1;
      _.offset = t2;
      _.center = t3;
      _.cacheExtent = t4;
      _.cacheExtentStyle = t5;
      _.clipBehavior = t6;
      _.children = t7;
      _.key = t8;
    },
    _ViewportElement: function _ViewportElement(t0, t1, t2) {
      var _ = this;
      _._viewport0$_doingMountOrUpdate = false;
      _._centerSlotIndex = null;
      _.__MultiChildRenderObjectElement__children_A = $;
      _._forgottenChildren = t0;
      _._slot = _._notificationTree = _._debugReassembleConfig = _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = null;
      _.__Element__depth_A = $;
      _._widget = t1;
      _._owner = null;
      _._lifecycleState = t2;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    },
    __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin: function __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin() {
    },
    __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin: function __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin() {
    },
    flipScrollDirection(direction) {
      switch (direction.index) {
        case 0:
          return C.ScrollDirection_0;
        case 1:
          return C.ScrollDirection_2;
        case 2:
          return C.ScrollDirection_1;
      }
    }
  },
  B, C, J, E, F, D;
  A = hunkHelpers.updateHolder(holdersList[21], A);
  B = holdersList[0];
  C = holdersList[2];
  J = holdersList[1];
  E = holdersList[32];
  F = holdersList[34];
  D = holdersList[23];
  A.RenderIndexedSemantics.prototype = {
    set$index(_, value) {
      if (value === this._proxy_box$_index)
        return;
      this._proxy_box$_index = value;
      this.markNeedsSemanticsUpdate$0();
    },
    describeSemanticsConfiguration$1(config) {
      this.super$RenderObject$describeSemanticsConfiguration(config);
      config._indexInParent = this._proxy_box$_index;
      config._hasBeenAnnotated = true;
    }
  };
  A.SliverConstraints.prototype = {
    get$isTight() {
      return false;
    },
    asBoxConstraints$2$maxExtent$minExtent(maxExtent, minExtent) {
      var crossAxisExtent = this.crossAxisExtent;
      switch (B.axisDirectionToAxis(this.axisDirection).index) {
        case 0:
          return new B.BoxConstraints(minExtent, maxExtent, crossAxisExtent, crossAxisExtent);
        case 1:
          return new B.BoxConstraints(crossAxisExtent, crossAxisExtent, minExtent, maxExtent);
      }
    },
    asBoxConstraints$0() {
      return this.asBoxConstraints$2$maxExtent$minExtent(1 / 0, 0);
    },
    $eq(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof A.SliverConstraints))
        return false;
      return other.axisDirection === _this.axisDirection && other.growthDirection === _this.growthDirection && other.scrollOffset === _this.scrollOffset && other.overlap === _this.overlap && other.remainingPaintExtent === _this.remainingPaintExtent && other.crossAxisExtent === _this.crossAxisExtent && other.crossAxisDirection === _this.crossAxisDirection && other.viewportMainAxisExtent === _this.viewportMainAxisExtent && other.remainingCacheExtent === _this.remainingCacheExtent && other.cacheOrigin === _this.cacheOrigin;
    },
    get$hashCode(_) {
      var _this = this;
      return B.Object_hash(_this.axisDirection, _this.growthDirection, _this.scrollOffset, _this.overlap, _this.remainingPaintExtent, _this.crossAxisExtent, _this.crossAxisDirection, _this.viewportMainAxisExtent, _this.remainingCacheExtent, _this.cacheOrigin, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue);
    },
    toString$0(_) {
      var _this = this,
        t1 = B._setArrayType([_this.axisDirection.toString$0(0), _this.growthDirection.toString$0(0), _this.userScrollDirection.toString$0(0), "scrollOffset: " + C.JSNumber_methods.toStringAsFixed$1(_this.scrollOffset, 1), "remainingPaintExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.remainingPaintExtent, 1)], type$.JSArray_String),
        t2 = _this.overlap;
      if (t2 !== 0)
        t1.push("overlap: " + C.JSNumber_methods.toStringAsFixed$1(t2, 1));
      t1.push("crossAxisExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.crossAxisExtent, 1));
      t1.push("crossAxisDirection: " + _this.crossAxisDirection.toString$0(0));
      t1.push("viewportMainAxisExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.viewportMainAxisExtent, 1));
      t1.push("remainingCacheExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.remainingCacheExtent, 1));
      t1.push("cacheOrigin: " + C.JSNumber_methods.toStringAsFixed$1(_this.cacheOrigin, 1));
      return "SliverConstraints(" + C.JSArray_methods.join$1(t1, ", ") + ")";
    }
  };
  A.SliverGeometry.prototype = {
    toStringShort$0() {
      return "SliverGeometry";
    }
  };
  A.SliverHitTestResult.prototype = {};
  A.SliverHitTestEntry.prototype = {
    toString$0(_) {
      return B.getRuntimeType(this.target).toString$0(0) + "@(mainAxis: " + B.S(this.mainAxisPosition) + ", crossAxis: " + B.S(this.crossAxisPosition) + ")";
    }
  };
  A.SliverLogicalParentData.prototype = {
    toString$0(_) {
      var t1 = this.layoutOffset;
      return "layoutOffset=" + (t1 == null ? "None" : C.JSNumber_methods.toStringAsFixed$1(t1, 1));
    }
  };
  A.SliverPhysicalParentData.prototype = {
    toString$0(_) {
      return "paintOffset=" + B.S(this.paintOffset);
    }
  };
  A.SliverPhysicalContainerParentData.prototype = {};
  A.RenderSliver.prototype = {
    get$constraints() {
      return type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this));
    },
    get$semanticBounds() {
      return this.get$paintBounds();
    },
    get$paintBounds() {
      var _this = this,
        t1 = type$.SliverConstraints;
      switch (B.axisDirectionToAxis(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection).index) {
        case 0:
          return new B.Rect(0, 0, 0 + _this._geometry.paintExtent, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(_this)).crossAxisExtent);
        case 1:
          return new B.Rect(0, 0, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(_this)).crossAxisExtent, 0 + _this._geometry.paintExtent);
      }
    },
    performResize$0() {
    },
    hitTest$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      var _this = this;
      if (mainAxisPosition >= 0 && mainAxisPosition < _this._geometry.hitTestExtent && crossAxisPosition >= 0 && crossAxisPosition < type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(_this)).crossAxisExtent)
        if (_this.hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) || false) {
          result.add$1(0, new A.SliverHitTestEntry(mainAxisPosition, crossAxisPosition, _this));
          return true;
        }
      return false;
    },
    hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      return false;
    },
    calculatePaintOffset$3$from$to(constraints, from, to) {
      var a = constraints.scrollOffset,
        t1 = constraints.remainingPaintExtent,
        b = a + t1;
      return B.clampDouble(B.clampDouble(to, a, b) - B.clampDouble(from, a, b), 0, t1);
    },
    calculateCacheOffset$3$from$to(constraints, from, to) {
      var t1 = constraints.scrollOffset,
        a = t1 + constraints.cacheOrigin,
        t2 = constraints.remainingCacheExtent,
        b = t1 + t2;
      return B.clampDouble(B.clampDouble(to, a, b) - B.clampDouble(from, a, b), 0, t2);
    },
    childScrollOffset$1(child) {
      return 0;
    },
    applyPaintTransform$2(child, transform) {
    },
    handleEvent$2($event, entry) {
    }
  };
  A.RenderSliverHelpers.prototype = {
    _getRightWayUp$1(constraints) {
      var rightWayUp;
      switch (constraints.axisDirection.index) {
        case 0:
        case 3:
          rightWayUp = false;
          break;
        case 2:
        case 1:
          rightWayUp = true;
          break;
        default:
          rightWayUp = null;
      }
      switch (constraints.growthDirection.index) {
        case 0:
          break;
        case 1:
          rightWayUp = !rightWayUp;
          break;
      }
      return rightWayUp;
    },
    hitTestBoxChild$4$crossAxisPosition$mainAxisPosition(result, child, crossAxisPosition, mainAxisPosition) {
      var delta, absolutePosition, absoluteCrossAxisPosition, paintOffset, _this = this, _box_0 = {},
        t1 = type$.SliverConstraints,
        rightWayUp = _this._getRightWayUp$1(t1._as(B.RenderObject.prototype.get$constraints.call(_this))),
        t2 = child.parentData;
      t2.toString;
      t2 = type$.SliverMultiBoxAdaptorParentData._as(t2).layoutOffset;
      t2.toString;
      delta = t2 - t1._as(B.RenderObject.prototype.get$constraints.call(_this)).scrollOffset;
      absolutePosition = mainAxisPosition - delta;
      absoluteCrossAxisPosition = crossAxisPosition - 0;
      paintOffset = _box_0.transformedPosition = null;
      switch (B.axisDirectionToAxis(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection).index) {
        case 0:
          if (!rightWayUp) {
            t1 = child._size._dx;
            absolutePosition = t1 - absolutePosition;
            delta = _this._geometry.paintExtent - t1 - delta;
          }
          paintOffset = new B.Offset(delta, 0);
          _box_0.transformedPosition = new B.Offset(absolutePosition, absoluteCrossAxisPosition);
          break;
        case 1:
          if (!rightWayUp) {
            t1 = child._size._dy;
            absolutePosition = t1 - absolutePosition;
            delta = _this._geometry.paintExtent - t1 - delta;
          }
          paintOffset = new B.Offset(0, delta);
          _box_0.transformedPosition = new B.Offset(absoluteCrossAxisPosition, absolutePosition);
          break;
      }
      return result.addWithOutOfBandPosition$2$hitTest$paintOffset(new A.RenderSliverHelpers_hitTestBoxChild_closure(_box_0, child), paintOffset);
    }
  };
  A._SliverGeometry_Object_Diagnosticable.prototype = {};
  A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin.prototype = {
    detach$0(_) {
      this.super$ParentData$detach(0);
    }
  };
  A.RenderSliverFixedExtentBoxAdaptor.prototype = {
    getMinChildIndexForScrollOffset$2(scrollOffset, itemExtent) {
      var actual, round;
      if (itemExtent > 0) {
        actual = scrollOffset / itemExtent;
        round = C.JSNumber_methods.round$0(actual);
        if (Math.abs(actual * itemExtent - round * itemExtent) < 1e-10)
          return round;
        return C.JSNumber_methods.floor$0(actual);
      }
      return 0;
    },
    getMaxChildIndexForScrollOffset$2(scrollOffset, itemExtent) {
      var actual, round;
      if (itemExtent > 0) {
        actual = scrollOffset / itemExtent - 1;
        round = C.JSNumber_methods.round$0(actual);
        if (Math.abs(actual * itemExtent - round * itemExtent) < 1e-10)
          return Math.max(0, round);
        return Math.max(0, C.JSNumber_methods.ceil$0(actual));
      }
      return 0;
    },
    _calculateLeadingGarbage$1(firstIndex) {
      var t3,
        walker = this.ContainerRenderObjectMixin__firstChild,
        t1 = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1"),
        t2 = type$.SliverMultiBoxAdaptorParentData,
        leadingGarbage = 0;
      while (true) {
        if (walker != null) {
          t3 = walker.parentData;
          t3.toString;
          t3 = t2._as(t3).index;
          t3.toString;
          t3 = t3 < firstIndex;
        } else
          t3 = false;
        if (!t3)
          break;
        ++leadingGarbage;
        t3 = walker.parentData;
        t3.toString;
        walker = t1._as(t3).ContainerParentDataMixin_nextSibling;
      }
      return leadingGarbage;
    },
    _calculateTrailingGarbage$1(targetLastIndex) {
      var t3,
        walker = this.ContainerRenderObjectMixin__lastChild,
        t1 = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1"),
        t2 = type$.SliverMultiBoxAdaptorParentData,
        trailingGarbage = 0;
      while (true) {
        if (walker != null) {
          t3 = walker.parentData;
          t3.toString;
          t3 = t2._as(t3).index;
          t3.toString;
          t3 = t3 > targetLastIndex;
        } else
          t3 = false;
        if (!t3)
          break;
        ++trailingGarbage;
        t3 = walker.parentData;
        t3.toString;
        walker = t1._as(t3).ContainerParentDataMixin_previousSibling;
      }
      return trailingGarbage;
    },
    performLayout$0() {
      var itemExtent, t2, scrollOffset, targetEndScrollOffset, childConstraints, firstIndex, targetLastIndex, leadingGarbage, max, t3, t4, index, trailingChildWithLayout, child, t5, estimatedMaxScrollOffset, t6, t7, leadingScrollOffset, trailingScrollOffset, paintExtent, cacheExtent, targetEndScrollOffsetForPaint, targetLastIndexForPaint, _this = this, _null = null,
        constraints = type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(_this)),
        t1 = _this._childManager;
      t1._didUnderflow = false;
      itemExtent = _this.get$itemExtent();
      t2 = constraints.scrollOffset;
      scrollOffset = t2 + constraints.cacheOrigin;
      targetEndScrollOffset = scrollOffset + constraints.remainingCacheExtent;
      childConstraints = constraints.asBoxConstraints$2$maxExtent$minExtent(itemExtent, itemExtent);
      firstIndex = _this.getMinChildIndexForScrollOffset$2(scrollOffset, itemExtent);
      targetLastIndex = isFinite(targetEndScrollOffset) ? _this.getMaxChildIndexForScrollOffset$2(targetEndScrollOffset, itemExtent) : _null;
      if (_this.ContainerRenderObjectMixin__firstChild != null) {
        leadingGarbage = _this._calculateLeadingGarbage$1(firstIndex);
        _this.collectGarbage$2(leadingGarbage, targetLastIndex != null ? _this._calculateTrailingGarbage$1(targetLastIndex) : 0);
      } else
        _this.collectGarbage$2(0, 0);
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        if (!_this.addInitialChild$2$index$layoutOffset(firstIndex, itemExtent * firstIndex)) {
          max = firstIndex <= 0 ? 0 : t1.get$childCount() * itemExtent;
          _this._geometry = A.SliverGeometry$(_null, false, _null, _null, max, 0, 0, max, _null);
          t1.didFinishLayout$0();
          return;
        }
      t3 = _this.ContainerRenderObjectMixin__firstChild;
      t3.toString;
      t3 = t3.parentData;
      t3.toString;
      t4 = type$.SliverMultiBoxAdaptorParentData;
      t3 = t4._as(t3).index;
      t3.toString;
      index = t3 - 1;
      trailingChildWithLayout = _null;
      for (; index >= firstIndex; --index) {
        child = _this.insertAndLayoutLeadingChild$1(childConstraints);
        if (child == null) {
          _this._geometry = A.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, index * itemExtent);
          return;
        }
        t3 = child.parentData;
        t3.toString;
        t4._as(t3).layoutOffset = itemExtent * index;
        if (trailingChildWithLayout == null)
          trailingChildWithLayout = child;
      }
      if (trailingChildWithLayout == null) {
        _this.ContainerRenderObjectMixin__firstChild.layout$1(childConstraints);
        trailingChildWithLayout = _this.ContainerRenderObjectMixin__firstChild;
        t3 = trailingChildWithLayout.parentData;
        t3.toString;
        t4._as(t3).layoutOffset = itemExtent * firstIndex;
      }
      t3 = trailingChildWithLayout.parentData;
      t3.toString;
      t3 = t4._as(t3).index;
      t3.toString;
      index = t3 + 1;
      t3 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1");
      t5 = targetLastIndex != null;
      while (true) {
        if (!(!t5 || index <= targetLastIndex)) {
          estimatedMaxScrollOffset = 1 / 0;
          break;
        }
        t6 = trailingChildWithLayout.parentData;
        t6.toString;
        child = t3._as(t6).ContainerParentDataMixin_nextSibling;
        if (child != null) {
          t6 = child.parentData;
          t6.toString;
          t6 = t4._as(t6).index;
          t6.toString;
          t6 = t6 !== index;
        } else
          t6 = true;
        if (t6) {
          child = _this.insertAndLayoutChild$2$after(childConstraints, trailingChildWithLayout);
          if (child == null) {
            estimatedMaxScrollOffset = index * itemExtent;
            break;
          }
        } else
          child.layout$1(childConstraints);
        t6 = child.parentData;
        t6.toString;
        t4._as(t6);
        t7 = t6.index;
        t7.toString;
        t6.layoutOffset = itemExtent * t7;
        ++index;
        trailingChildWithLayout = child;
      }
      t3 = _this.ContainerRenderObjectMixin__lastChild;
      t3.toString;
      t3 = t3.parentData;
      t3.toString;
      t3 = t4._as(t3).index;
      t3.toString;
      leadingScrollOffset = itemExtent * firstIndex;
      trailingScrollOffset = itemExtent * (t3 + 1);
      estimatedMaxScrollOffset = Math.min(estimatedMaxScrollOffset, t1.estimateMaxScrollOffset$5$firstIndex$lastIndex$leadingScrollOffset$trailingScrollOffset(constraints, firstIndex, t3, leadingScrollOffset, trailingScrollOffset));
      paintExtent = _this.calculatePaintOffset$3$from$to(constraints, leadingScrollOffset, trailingScrollOffset);
      cacheExtent = _this.calculateCacheOffset$3$from$to(constraints, leadingScrollOffset, trailingScrollOffset);
      targetEndScrollOffsetForPaint = t2 + constraints.remainingPaintExtent;
      targetLastIndexForPaint = isFinite(targetEndScrollOffsetForPaint) ? _this.getMaxChildIndexForScrollOffset$2(targetEndScrollOffsetForPaint, itemExtent) : _null;
      _this._geometry = A.SliverGeometry$(cacheExtent, targetLastIndexForPaint != null && t3 >= targetLastIndexForPaint || t2 > 0, _null, _null, estimatedMaxScrollOffset, paintExtent, 0, estimatedMaxScrollOffset, _null);
      if (estimatedMaxScrollOffset === trailingScrollOffset)
        t1._didUnderflow = true;
      t1.didFinishLayout$0();
    }
  };
  A.KeepAliveParentDataMixin.prototype = {$isParentData: 1};
  A.RenderSliverWithKeepAliveMixin.prototype = {
    setupParentData$1(child) {
    }
  };
  A.SliverMultiBoxAdaptorParentData.prototype = {
    toString$0(_) {
      var t1 = this.index,
        t2 = this.KeepAliveParentDataMixin_keepAlive ? "keepAlive; " : "";
      return "index=" + B.S(t1) + "; " + t2 + this.super$SliverLogicalParentData$toString(0);
    }
  };
  A.RenderSliverMultiBoxAdaptor.prototype = {
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverMultiBoxAdaptorParentData))
        child.parentData = new A.SliverMultiBoxAdaptorParentData(false, null, null);
    },
    adoptChild$1(child) {
      var t1;
      this.super$RenderObject$adoptChild(child);
      t1 = child.parentData;
      t1.toString;
      if (!type$.SliverMultiBoxAdaptorParentData._as(t1)._keptAlive)
        this._childManager.didAdoptChild$1(type$.RenderBox._as(child));
    },
    insert$2$after(_, child, after) {
      this.super$ContainerRenderObjectMixin$insert(0, child, after);
    },
    move$2$after(child, after) {
      var t2, _this = this,
        t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1);
      if (!t1._keptAlive) {
        _this.super$ContainerRenderObjectMixin$move(child, after);
        _this._childManager.didAdoptChild$1(child);
        _this.markNeedsLayout$0();
      } else {
        t2 = _this._keepAliveBucket;
        if (t2.$index(0, t1.index) === child)
          t2.remove$1(0, t1.index);
        _this._childManager.didAdoptChild$1(child);
        t1 = t1.index;
        t1.toString;
        t2.$indexSet(0, t1, child);
      }
    },
    remove$1(_, child) {
      var t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1);
      if (!t1._keptAlive) {
        this.super$ContainerRenderObjectMixin$remove(0, child);
        return;
      }
      this._keepAliveBucket.remove$1(0, t1.index);
      this.dropChild$1(child);
    },
    _createOrObtainChild$2$after(index, after) {
      this.invokeLayoutCallback$1$1(new A.RenderSliverMultiBoxAdaptor__createOrObtainChild_closure(this, index, after), type$.SliverConstraints);
    },
    _destroyOrCacheChild$1(child) {
      var t2, _this = this,
        t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1);
      if (t1.KeepAliveParentDataMixin_keepAlive) {
        _this.remove$1(0, child);
        t2 = t1.index;
        t2.toString;
        _this._keepAliveBucket.$indexSet(0, t2, child);
        child.parentData = t1;
        _this.super$RenderObject$adoptChild(child);
        t1._keptAlive = true;
      } else
        _this._childManager.removeChild$1(child);
    },
    attach$1(owner) {
      var t1, t2, t3;
      this.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$attach(owner);
      for (t1 = this._keepAliveBucket, t1 = t1.get$values(t1), t2 = B._instanceType(t1), t2 = t2._eval$1("@<1>")._bind$1(t2._rest[1]), t1 = new B.MappedIterator(J.get$iterator$ax(t1.__internal$_iterable), t1._f, t2._eval$1("MappedIterator<1,2>")), t2 = t2._rest[1]; t1.moveNext$0();) {
        t3 = t1.__internal$_current;
        (t3 == null ? t2._as(t3) : t3).attach$1(owner);
      }
    },
    detach$0(_) {
      var t1, t2, t3;
      this.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$detach(0);
      for (t1 = this._keepAliveBucket, t1 = t1.get$values(t1), t2 = B._instanceType(t1), t2 = t2._eval$1("@<1>")._bind$1(t2._rest[1]), t1 = new B.MappedIterator(J.get$iterator$ax(t1.__internal$_iterable), t1._f, t2._eval$1("MappedIterator<1,2>")), t2 = t2._rest[1]; t1.moveNext$0();) {
        t3 = t1.__internal$_current;
        (t3 == null ? t2._as(t3) : t3).detach$0(0);
      }
    },
    redepthChildren$0() {
      this.super$ContainerRenderObjectMixin$redepthChildren();
      var t1 = this._keepAliveBucket;
      t1.get$values(t1).forEach$1(0, this.get$redepthChild());
    },
    visitChildren$1(visitor) {
      var t1;
      this.super$ContainerRenderObjectMixin$visitChildren(visitor);
      t1 = this._keepAliveBucket;
      t1.get$values(t1).forEach$1(0, visitor);
    },
    visitChildrenForSemantics$1(visitor) {
      this.super$ContainerRenderObjectMixin$visitChildren(visitor);
    },
    addInitialChild$2$index$layoutOffset(index, layoutOffset) {
      var t1;
      this._createOrObtainChild$2$after(index, null);
      t1 = this.ContainerRenderObjectMixin__firstChild;
      if (t1 != null) {
        t1 = t1.parentData;
        t1.toString;
        type$.SliverMultiBoxAdaptorParentData._as(t1).layoutOffset = layoutOffset;
        return true;
      }
      this._childManager._didUnderflow = true;
      return false;
    },
    addInitialChild$0() {
      return this.addInitialChild$2$index$layoutOffset(0, 0);
    },
    insertAndLayoutLeadingChild$2$parentUsesSize(childConstraints, parentUsesSize) {
      var t2, index, t3, _this = this,
        t1 = _this.ContainerRenderObjectMixin__firstChild;
      t1.toString;
      t1 = t1.parentData;
      t1.toString;
      t2 = type$.SliverMultiBoxAdaptorParentData;
      t1 = t2._as(t1).index;
      t1.toString;
      index = t1 - 1;
      _this._createOrObtainChild$2$after(index, null);
      t1 = _this.ContainerRenderObjectMixin__firstChild;
      t1.toString;
      t3 = t1.parentData;
      t3.toString;
      t3 = t2._as(t3).index;
      t3.toString;
      if (t3 === index) {
        t1.layout$2$parentUsesSize(childConstraints, parentUsesSize);
        return _this.ContainerRenderObjectMixin__firstChild;
      }
      _this._childManager._didUnderflow = true;
      return null;
    },
    insertAndLayoutLeadingChild$1(childConstraints) {
      return this.insertAndLayoutLeadingChild$2$parentUsesSize(childConstraints, false);
    },
    insertAndLayoutChild$3$after$parentUsesSize(childConstraints, after, parentUsesSize) {
      var t2, index, child,
        t1 = after.parentData;
      t1.toString;
      t2 = type$.SliverMultiBoxAdaptorParentData;
      t1 = t2._as(t1).index;
      t1.toString;
      index = t1 + 1;
      this._createOrObtainChild$2$after(index, after);
      t1 = after.parentData;
      t1.toString;
      child = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1")._as(t1).ContainerParentDataMixin_nextSibling;
      if (child != null) {
        t1 = child.parentData;
        t1.toString;
        t1 = t2._as(t1).index;
        t1.toString;
        t1 = t1 === index;
      } else
        t1 = false;
      if (t1) {
        child.layout$2$parentUsesSize(childConstraints, parentUsesSize);
        return child;
      }
      this._childManager._didUnderflow = true;
      return null;
    },
    insertAndLayoutChild$2$after(childConstraints, after) {
      return this.insertAndLayoutChild$3$after$parentUsesSize(childConstraints, after, false);
    },
    collectGarbage$2(leadingGarbage, trailingGarbage) {
      var t1 = {};
      t1.leadingGarbage = leadingGarbage;
      t1.trailingGarbage = trailingGarbage;
      this.invokeLayoutCallback$1$1(new A.RenderSliverMultiBoxAdaptor_collectGarbage_closure(t1, this), type$.SliverConstraints);
    },
    paintExtentOf$1(child) {
      switch (B.axisDirectionToAxis(type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this)).axisDirection).index) {
        case 0:
          return child._size._dx;
        case 1:
          return child._size._dy;
      }
    },
    hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      var t1, t2,
        child = this.ContainerRenderObjectMixin__lastChild,
        boxResult = B.BoxHitTestResult$wrap(result);
      for (t1 = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1"); child != null;) {
        if (this.hitTestBoxChild$4$crossAxisPosition$mainAxisPosition(boxResult, child, crossAxisPosition, mainAxisPosition))
          return true;
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_previousSibling;
      }
      return false;
    },
    childScrollOffset$1(child) {
      var t1 = child.parentData;
      t1.toString;
      return type$.SliverMultiBoxAdaptorParentData._as(t1).layoutOffset;
    },
    paintsChild$1(child) {
      var childParentData = type$.nullable_SliverMultiBoxAdaptorParentData._as(child.parentData);
      return (childParentData == null ? null : childParentData.index) != null && !this._keepAliveBucket.containsKey$1(0, childParentData.index);
    },
    applyPaintTransform$2(child, transform) {
      var t1, rightWayUp, t2, delta, _this = this;
      if (!_this.paintsChild$1(child))
        transform.setZero$0();
      else {
        t1 = type$.SliverConstraints;
        rightWayUp = _this._getRightWayUp$1(t1._as(B.RenderObject.prototype.get$constraints.call(_this)));
        t2 = child.parentData;
        t2.toString;
        t2 = type$.SliverMultiBoxAdaptorParentData._as(t2).layoutOffset;
        t2.toString;
        delta = t2 - t1._as(B.RenderObject.prototype.get$constraints.call(_this)).scrollOffset;
        switch (B.axisDirectionToAxis(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection).index) {
          case 0:
            transform.translate$2(0, !rightWayUp ? _this._geometry.paintExtent - child._size._dx - delta : delta, 0);
            break;
          case 1:
            transform.translate$2(0, 0, !rightWayUp ? _this._geometry.paintExtent - child._size._dy - delta : delta);
            break;
        }
      }
    },
    paint$2(context, offset) {
      var t1, originOffset, mainAxisUnit, crossAxisUnit, addExtent, child, t2, t3, t4, mainAxisDelta, t5, t6, t7, childOffset, t8, _this = this, _null = null;
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        return;
      t1 = type$.SliverConstraints;
      switch (B.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(_this)).growthDirection)) {
        case C.AxisDirection_0:
          originOffset = offset.$add(0, new B.Offset(0, _this._geometry.paintExtent));
          mainAxisUnit = E.Offset_0_m1;
          crossAxisUnit = C.Offset_1_0;
          addExtent = true;
          break;
        case C.AxisDirection_1:
          originOffset = offset;
          mainAxisUnit = C.Offset_1_0;
          crossAxisUnit = C.Offset_0_1;
          addExtent = false;
          break;
        case C.AxisDirection_2:
          originOffset = offset;
          mainAxisUnit = C.Offset_0_1;
          crossAxisUnit = C.Offset_1_0;
          addExtent = false;
          break;
        case C.AxisDirection_3:
          originOffset = offset.$add(0, new B.Offset(_this._geometry.paintExtent, 0));
          mainAxisUnit = E.Offset_m1_0;
          crossAxisUnit = C.Offset_0_1;
          addExtent = true;
          break;
        default:
          addExtent = _null;
          originOffset = addExtent;
          crossAxisUnit = originOffset;
          mainAxisUnit = crossAxisUnit;
      }
      child = _this.ContainerRenderObjectMixin__firstChild;
      for (t2 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"), t3 = type$.SliverMultiBoxAdaptorParentData; child != null;) {
        t4 = child.parentData;
        t4.toString;
        t4 = t3._as(t4).layoutOffset;
        t4.toString;
        mainAxisDelta = t4 - t1._as(B.RenderObject.prototype.get$constraints.call(_this)).scrollOffset;
        t4 = originOffset._dx;
        t5 = mainAxisUnit._dx;
        t4 = t4 + t5 * mainAxisDelta + crossAxisUnit._dx * 0;
        t6 = originOffset._dy;
        t7 = mainAxisUnit._dy;
        t6 = t6 + t7 * mainAxisDelta + crossAxisUnit._dy * 0;
        childOffset = new B.Offset(t4, t6);
        if (addExtent) {
          t8 = _this.paintExtentOf$1(child);
          childOffset = new B.Offset(t4 + t5 * t8, t6 + t7 * t8);
        }
        if (mainAxisDelta < t1._as(B.RenderObject.prototype.get$constraints.call(_this)).remainingPaintExtent && mainAxisDelta + _this.paintExtentOf$1(child) > 0)
          context.paintChild$2(child, childOffset);
        t4 = child.parentData;
        t4.toString;
        child = t2._as(t4).ContainerParentDataMixin_nextSibling;
      }
    },
    debugDescribeChildren$0() {
      var t1, t2, indices, _i, index, t3,
        _s17_ = "child with index ",
        children = B._setArrayType([], type$.JSArray_DiagnosticsNode),
        child = this.ContainerRenderObjectMixin__firstChild;
      if (child != null)
        for (t1 = type$.SliverMultiBoxAdaptorParentData; true;) {
          t2 = child.parentData;
          t2.toString;
          t1._as(t2);
          children.push(new B.DiagnosticableTreeNode(child, _s17_ + B.S(t2.index), true, true, null, null));
          if (child == this.ContainerRenderObjectMixin__lastChild)
            break;
          child = t2.ContainerParentDataMixin_nextSibling;
        }
      t1 = this._keepAliveBucket;
      if (t1._length !== 0) {
        t2 = B._instanceType(t1)._eval$1("LinkedHashMapKeyIterable<1>");
        indices = B.List_List$of(new B.LinkedHashMapKeyIterable(t1, t2), true, t2._eval$1("Iterable.E"));
        C.JSArray_methods.sort$0(indices);
        for (t2 = indices.length, _i = 0; _i < indices.length; indices.length === t2 || (0, B.throwConcurrentModificationError)(indices), ++_i) {
          index = indices[_i];
          t3 = t1.$index(0, index);
          t3.toString;
          children.push(new B.DiagnosticableTreeNode(t3, _s17_ + B.S(index) + " (kept alive but not laid out)", true, true, null, C.DiagnosticsTreeStyle_2));
        }
      }
      return children;
    }
  };
  A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin.prototype = {
    attach$1(owner) {
      var child, t1, t2;
      this.super$RenderObject$attach(owner);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = type$.SliverMultiBoxAdaptorParentData; child != null;) {
        child.attach$1(owner);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    },
    detach$0(_) {
      var child, t1, t2;
      this.super$AbstractNode$detach(0);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = type$.SliverMultiBoxAdaptorParentData; child != null;) {
        child.detach$0(0);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    }
  };
  A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers.prototype = {};
  A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin.prototype = {};
  A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin.prototype = {
    detach$0(_) {
      this.super$ParentData$detach(0);
    }
  };
  A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin.prototype = {};
  A.RenderSliverEdgeInsetsPadding.prototype = {
    get$beforePadding() {
      var _this = this,
        t1 = type$.SliverConstraints;
      switch (B.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(_this)).growthDirection)) {
        case C.AxisDirection_0:
          return _this.get$resolvedPadding().bottom;
        case C.AxisDirection_1:
          return _this.get$resolvedPadding().left;
        case C.AxisDirection_2:
          return _this.get$resolvedPadding().top;
        case C.AxisDirection_3:
          return _this.get$resolvedPadding().right;
      }
    },
    get$afterPadding() {
      var _this = this,
        t1 = type$.SliverConstraints;
      switch (B.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(_this)).growthDirection)) {
        case C.AxisDirection_0:
          return _this.get$resolvedPadding().top;
        case C.AxisDirection_1:
          return _this.get$resolvedPadding().right;
        case C.AxisDirection_2:
          return _this.get$resolvedPadding().bottom;
        case C.AxisDirection_3:
          return _this.get$resolvedPadding().left;
      }
    },
    get$crossAxisPadding() {
      switch (B.axisDirectionToAxis(type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this)).axisDirection).index) {
        case 0:
          var t1 = this.get$resolvedPadding();
          return t1.get$_top(t1) + t1.get$_bottom(t1);
        case 1:
          return this.get$resolvedPadding().get$horizontal();
      }
    },
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverPhysicalParentData))
        child.parentData = new A.SliverPhysicalParentData(C.Offset_0_0);
    },
    performLayout$0() {
      var t2, crossAxisPadding, paintExtent, beforePaddingPaintExtent, overlap, t3, t4, t5, t6, t7, t8, t9, t10, t11, childLayoutGeometry, afterPaddingPaintExtent, mainAxisPaddingPaintExtent, beforePaddingCacheExtent, afterPaddingCacheExtent, _this = this, _null = null,
        t1 = type$.SliverConstraints,
        constraints = t1._as(B.RenderObject.prototype.get$constraints.call(_this)),
        beforePadding = _this.get$beforePadding();
      _this.get$afterPadding();
      t2 = _this.get$resolvedPadding();
      t2.toString;
      t1 = t2.along$1(B.axisDirectionToAxis(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection));
      crossAxisPadding = _this.get$crossAxisPadding();
      if (_this.RenderObjectWithChildMixin__child == null) {
        paintExtent = _this.calculatePaintOffset$3$from$to(constraints, 0, t1);
        _this._geometry = A.SliverGeometry$(_this.calculateCacheOffset$3$from$to(constraints, 0, t1), false, _null, _null, t1, Math.min(paintExtent, constraints.remainingPaintExtent), 0, t1, _null);
        return;
      }
      beforePaddingPaintExtent = _this.calculatePaintOffset$3$from$to(constraints, 0, beforePadding);
      overlap = constraints.overlap;
      if (overlap > 0)
        overlap = Math.max(0, overlap - beforePaddingPaintExtent);
      t2 = _this.RenderObjectWithChildMixin__child;
      t2.toString;
      t3 = Math.max(0, constraints.scrollOffset - beforePadding);
      t4 = Math.min(0, constraints.cacheOrigin + beforePadding);
      t5 = constraints.remainingPaintExtent;
      t6 = _this.calculatePaintOffset$3$from$to(constraints, 0, beforePadding);
      t7 = constraints.remainingCacheExtent;
      t8 = _this.calculateCacheOffset$3$from$to(constraints, 0, beforePadding);
      t9 = Math.max(0, constraints.crossAxisExtent - crossAxisPadding);
      t10 = constraints.axisDirection;
      t11 = constraints.growthDirection;
      t2.layout$2$parentUsesSize(new A.SliverConstraints(t10, t11, constraints.userScrollDirection, t3, beforePadding + constraints.precedingScrollExtent, overlap, t5 - t6, t9, constraints.crossAxisDirection, constraints.viewportMainAxisExtent, t4, t7 - t8), true);
      childLayoutGeometry = _this.RenderObjectWithChildMixin__child._geometry;
      t2 = childLayoutGeometry.scrollOffsetCorrection;
      if (t2 != null) {
        _this._geometry = A.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, t2);
        return;
      }
      t2 = childLayoutGeometry.scrollExtent;
      t3 = beforePadding + t2;
      t4 = t1 + t2;
      afterPaddingPaintExtent = _this.calculatePaintOffset$3$from$to(constraints, t3, t4);
      mainAxisPaddingPaintExtent = beforePaddingPaintExtent + afterPaddingPaintExtent;
      beforePaddingCacheExtent = _this.calculateCacheOffset$3$from$to(constraints, 0, beforePadding);
      afterPaddingCacheExtent = _this.calculateCacheOffset$3$from$to(constraints, t3, t4);
      t3 = childLayoutGeometry.paintExtent;
      t6 = childLayoutGeometry.layoutExtent;
      paintExtent = Math.min(beforePaddingPaintExtent + Math.max(t3, t6 + afterPaddingPaintExtent), t5);
      t5 = childLayoutGeometry.paintOrigin;
      t6 = Math.min(mainAxisPaddingPaintExtent + t6, paintExtent);
      t7 = Math.min(afterPaddingCacheExtent + beforePaddingCacheExtent + childLayoutGeometry.cacheExtent, t7);
      t8 = childLayoutGeometry.maxPaintExtent;
      t3 = Math.max(mainAxisPaddingPaintExtent + t3, beforePaddingPaintExtent + childLayoutGeometry.hitTestExtent);
      _this._geometry = A.SliverGeometry$(t7, childLayoutGeometry.hasVisualOverflow, t3, t6, t1 + t8, paintExtent, t5, t4, _null);
      t4 = _this.RenderObjectWithChildMixin__child.parentData;
      t4.toString;
      type$.SliverPhysicalParentData._as(t4);
      switch (B.applyGrowthDirectionToAxisDirection(t10, t11)) {
        case C.AxisDirection_0:
          t4.paintOffset = new B.Offset(_this.get$resolvedPadding().left, _this.calculatePaintOffset$3$from$to(constraints, _this.get$resolvedPadding().bottom + t2, _this.get$resolvedPadding().bottom + t2 + _this.get$resolvedPadding().top));
          break;
        case C.AxisDirection_1:
          t4.paintOffset = new B.Offset(_this.calculatePaintOffset$3$from$to(constraints, 0, _this.get$resolvedPadding().left), _this.get$resolvedPadding().top);
          break;
        case C.AxisDirection_2:
          t4.paintOffset = new B.Offset(_this.get$resolvedPadding().left, _this.calculatePaintOffset$3$from$to(constraints, 0, _this.get$resolvedPadding().top));
          break;
        case C.AxisDirection_3:
          t4.paintOffset = new B.Offset(_this.calculatePaintOffset$3$from$to(constraints, _this.get$resolvedPadding().right + t2, _this.get$resolvedPadding().right + t2 + _this.get$resolvedPadding().left), _this.get$resolvedPadding().top);
          break;
      }
    },
    hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      var t2, t3, t4, t5, _this = this,
        t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null && t1._geometry.hitTestExtent > 0) {
        t1 = t1.parentData;
        t1.toString;
        type$.SliverPhysicalParentData._as(t1);
        t2 = _this.calculatePaintOffset$3$from$to(type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(_this)), 0, _this.get$beforePadding());
        t3 = _this.RenderObjectWithChildMixin__child;
        t3.toString;
        t3 = _this.childCrossAxisPosition$1(t3);
        t1 = t1.paintOffset;
        t4 = _this.RenderObjectWithChildMixin__child.get$hitTest();
        t5 = t1 != null;
        if (t5)
          result._localTransforms.push(new B._OffsetTransformPart(new B.Offset(-t1._dx, -t1._dy)));
        t4.call$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition - t3, mainAxisPosition - t2);
        if (t5)
          result.popTransform$0();
      }
      return false;
    },
    childCrossAxisPosition$1(child) {
      var _this = this,
        t1 = type$.SliverConstraints;
      switch (B.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(_this)).growthDirection)) {
        case C.AxisDirection_0:
        case C.AxisDirection_2:
          return _this.get$resolvedPadding().left;
        case C.AxisDirection_3:
        case C.AxisDirection_1:
          return _this.get$resolvedPadding().top;
      }
    },
    childScrollOffset$1(child) {
      return this.get$beforePadding();
    },
    applyPaintTransform$2(child, transform) {
      var t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverPhysicalParentData._as(t1).paintOffset;
      transform.translate$2(0, t1._dx, t1._dy);
    },
    paint$2(context, offset) {
      var t2,
        t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null && t1._geometry.visible) {
        t2 = t1.parentData;
        t2.toString;
        context.paintChild$2(t1, offset.$add(0, type$.SliverPhysicalParentData._as(t2).paintOffset));
      }
    }
  };
  A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin.prototype = {
    attach$1(owner) {
      var t1;
      this.super$RenderObject$attach(owner);
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.attach$1(owner);
    },
    detach$0(_) {
      var t1;
      this.super$AbstractNode$detach(0);
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.detach$0(0);
    }
  };
  A.CacheExtentStyle.prototype = {
    toString$0(_) {
      return "CacheExtentStyle." + this._core$_name;
    }
  };
  A.RenderViewportBase.prototype = {
    describeSemanticsConfiguration$1(config) {
      this.super$RenderObject$describeSemanticsConfiguration(config);
      config.addTagForChildren$1(F.SemanticsTag_FIw);
    },
    visitChildrenForSemantics$1(visitor) {
      var t1 = this.get$childrenInPaintOrder();
      new B.WhereIterable(t1, new A.RenderViewportBase_visitChildrenForSemantics_closure(), B.instanceType(t1)._eval$1("WhereIterable<1>")).forEach$1(0, visitor);
    },
    set$axisDirection(value) {
      if (value === this._viewport$_axisDirection)
        return;
      this._viewport$_axisDirection = value;
      this.markNeedsLayout$0();
    },
    set$crossAxisDirection(value) {
      if (value === this._crossAxisDirection)
        return;
      this._crossAxisDirection = value;
      this.markNeedsLayout$0();
    },
    set$offset(_, value) {
      var _this = this,
        t1 = _this._viewport$_offset;
      if (value === t1)
        return;
      if (_this._node$_owner != null)
        t1.removeListener$1(0, _this.get$markNeedsLayout());
      _this._viewport$_offset = value;
      if (_this._node$_owner != null)
        value.addListener$1(0, _this.get$markNeedsLayout());
      _this.markNeedsLayout$0();
    },
    set$cacheExtent(value) {
      if (value == null)
        value = 250;
      if (value === this._cacheExtent)
        return;
      this._cacheExtent = value;
      this.markNeedsLayout$0();
    },
    set$cacheExtentStyle(value) {
      if (value === this._cacheExtentStyle)
        return;
      this._cacheExtentStyle = value;
      this.markNeedsLayout$0();
    },
    set$clipBehavior(value) {
      var _this = this;
      if (value !== _this._viewport$_clipBehavior) {
        _this._viewport$_clipBehavior = value;
        _this.markNeedsPaint$0();
        _this.markNeedsSemanticsUpdate$0();
      }
    },
    attach$1(owner) {
      this.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$attach(owner);
      this._viewport$_offset.addListener$1(0, this.get$markNeedsLayout());
    },
    detach$0(_) {
      this._viewport$_offset.removeListener$1(0, this.get$markNeedsLayout());
      this.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$detach(0);
    },
    get$isRepaintBoundary() {
      return true;
    },
    layoutChildSequence$11$advance$cacheOrigin$child$crossAxisExtent$growthDirection$layoutOffset$mainAxisExtent$overlap$remainingCacheExtent$remainingPaintExtent$scrollOffset(advance, cacheOrigin, child, crossAxisExtent, growthDirection, layoutOffset, mainAxisExtent, overlap, remainingCacheExtent, remainingPaintExtent, scrollOffset) {
      var layoutOffset0, precedingScrollExtent, sliverScrollOffset, correctedCacheOrigin, cacheExtentCorrection, childLayoutGeometry, t1, effectiveLayoutOffset, _this = this,
        adjustedUserScrollDirection = A.applyGrowthDirectionToScrollDirection(_this._viewport$_offset._userScrollDirection, growthDirection),
        maxPaintOffset = layoutOffset + overlap;
      for (layoutOffset0 = layoutOffset, precedingScrollExtent = 0; child != null;) {
        sliverScrollOffset = scrollOffset <= 0 ? 0 : scrollOffset;
        correctedCacheOrigin = Math.max(cacheOrigin, -sliverScrollOffset);
        cacheExtentCorrection = cacheOrigin - correctedCacheOrigin;
        child.layout$2$parentUsesSize(new A.SliverConstraints(_this._viewport$_axisDirection, growthDirection, adjustedUserScrollDirection, sliverScrollOffset, precedingScrollExtent, maxPaintOffset - layoutOffset0, Math.max(0, remainingPaintExtent - layoutOffset0 + layoutOffset), crossAxisExtent, _this._crossAxisDirection, mainAxisExtent, correctedCacheOrigin, Math.max(0, remainingCacheExtent + cacheExtentCorrection)), true);
        childLayoutGeometry = child._geometry;
        t1 = childLayoutGeometry.scrollOffsetCorrection;
        if (t1 != null)
          return t1;
        effectiveLayoutOffset = layoutOffset0 + childLayoutGeometry.paintOrigin;
        if (childLayoutGeometry.visible || scrollOffset > 0)
          _this.updateChildLayoutOffset$3(child, effectiveLayoutOffset, growthDirection);
        else
          _this.updateChildLayoutOffset$3(child, -scrollOffset + layoutOffset, growthDirection);
        maxPaintOffset = Math.max(effectiveLayoutOffset + childLayoutGeometry.paintExtent, maxPaintOffset);
        t1 = childLayoutGeometry.scrollExtent;
        scrollOffset -= t1;
        precedingScrollExtent += t1;
        layoutOffset0 += childLayoutGeometry.layoutExtent;
        t1 = childLayoutGeometry.cacheExtent;
        if (t1 !== 0) {
          remainingCacheExtent -= t1 - cacheExtentCorrection;
          cacheOrigin = Math.min(correctedCacheOrigin + t1, 0);
        }
        _this.updateOutOfBandData$2(growthDirection, childLayoutGeometry);
        child = advance.call$1(child);
      }
      return 0;
    },
    describeApproximatePaintClip$1(child) {
      var t1, right, bottom, overlapCorrection, $top, left;
      switch (this._viewport$_clipBehavior.index) {
        case 0:
          return null;
        case 1:
        case 2:
        case 3:
          break;
      }
      t1 = this._size;
      right = 0 + t1._dx;
      bottom = 0 + t1._dy;
      t1 = type$.SliverConstraints;
      if (t1._as(B.RenderObject.prototype.get$constraints.call(child)).overlap === 0 || !isFinite(t1._as(B.RenderObject.prototype.get$constraints.call(child)).viewportMainAxisExtent))
        return new B.Rect(0, 0, right, bottom);
      overlapCorrection = t1._as(B.RenderObject.prototype.get$constraints.call(child)).viewportMainAxisExtent - t1._as(B.RenderObject.prototype.get$constraints.call(child)).remainingPaintExtent + t1._as(B.RenderObject.prototype.get$constraints.call(child)).overlap;
      switch (B.applyGrowthDirectionToAxisDirection(this._viewport$_axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection)) {
        case C.AxisDirection_2:
          $top = 0 + overlapCorrection;
          left = 0;
          break;
        case C.AxisDirection_0:
          bottom -= overlapCorrection;
          left = 0;
          $top = 0;
          break;
        case C.AxisDirection_1:
          left = 0 + overlapCorrection;
          $top = 0;
          break;
        case C.AxisDirection_3:
          right -= overlapCorrection;
          left = 0;
          $top = 0;
          break;
        default:
          left = 0;
          $top = 0;
      }
      return new B.Rect(left, $top, right, bottom);
    },
    describeSemanticsClip$1(child) {
      var t2, _this = this,
        t1 = _this._calculatedCacheExtent;
      if (t1 == null) {
        t1 = _this._size;
        return new B.Rect(0, 0, 0 + t1._dx, 0 + t1._dy);
      }
      switch (B.axisDirectionToAxis(_this._viewport$_axisDirection).index) {
        case 1:
          t2 = _this._size;
          return new B.Rect(0, 0 - t1, 0 + t2._dx, 0 + t2._dy + t1);
        case 0:
          t2 = _this._size;
          return new B.Rect(0 - t1, 0, 0 + t2._dx + t1, 0 + t2._dy);
      }
    },
    paint$2(context, offset) {
      var t1, t2, t3, _this = this;
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        return;
      t1 = _this.get$hasVisualOverflow() && _this._viewport$_clipBehavior !== C.Clip_0;
      t2 = _this._viewport$_clipRectLayer;
      if (t1) {
        t1 = _this.__RenderObject__needsCompositing_A;
        t1 === $ && B.throwUnnamedLateFieldNI();
        t3 = _this._size;
        t2.set$layer(0, context.pushClipRect$6$clipBehavior$oldLayer(t1, offset, new B.Rect(0, 0, 0 + t3._dx, 0 + t3._dy), _this.get$_paintContents(), _this._viewport$_clipBehavior, t2._layer));
      } else {
        t2.set$layer(0, null);
        _this._paintContents$2(context, offset);
      }
    },
    dispose$0() {
      this._viewport$_clipRectLayer.set$layer(0, null);
      this.super$RenderObject$dispose();
    },
    _paintContents$2(context, offset) {
      var t1, t2, t3, t4, _i, child, t5;
      for (t1 = this.get$childrenInPaintOrder(), t2 = t1.length, t3 = offset._dx, t4 = offset._dy, _i = 0; _i < t1.length; t1.length === t2 || (0, B.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        if (child._geometry.visible) {
          t5 = this.paintOffsetOf$1(child);
          context.paintChild$2(child, new B.Offset(t3 + t5._dx, t4 + t5._dy));
        }
      }
    },
    hitTestChildren$2$position(result, position) {
      var sliverResult, t1, t2, _i, child, transform, _this = this, _box_0 = {};
      _box_0.crossAxisPosition = _box_0.mainAxisPosition = null;
      switch (B.axisDirectionToAxis(_this._viewport$_axisDirection).index) {
        case 1:
          _box_0.mainAxisPosition = position._dy;
          _box_0.crossAxisPosition = position._dx;
          break;
        case 0:
          _box_0.mainAxisPosition = position._dx;
          _box_0.crossAxisPosition = position._dy;
          break;
      }
      sliverResult = new A.SliverHitTestResult(result._path, result._transforms, result._localTransforms);
      for (t1 = _this.get$childrenInHitTestOrder(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, B.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        if (!child._geometry.visible)
          continue;
        transform = new B.Matrix4(new Float64Array(16));
        transform.setIdentity$0();
        _this.applyPaintTransform$2(child, transform);
        if (result.addWithOutOfBandPosition$2$hitTest$paintTransform(new A.RenderViewportBase_hitTestChildren_closure(_box_0, _this, child, sliverResult), transform))
          return true;
      }
      return false;
    },
    getOffsetToReveal$3$rect(target, alignment, rect) {
      var t1, pivot, child, leadingScrollOffset, t2, t3, growthDirection, pivotExtent, rectLocal, targetMainAxisExtent, targetRect, extentOfPinnedSlivers, mainAxisExtent, targetOffset, offsetDifference, _this = this, _null = null,
        onlySlivers = target instanceof A.RenderSliver;
      for (t1 = type$.RenderObject, pivot = _null, child = target, leadingScrollOffset = 0; child.get$parent(child) !== _this; child = t2) {
        t2 = child.get$parent(child);
        t2.toString;
        t1._as(t2);
        if (child instanceof B.RenderBox)
          pivot = child;
        if (t2 instanceof A.RenderSliver) {
          t3 = t2.childScrollOffset$1(child);
          t3.toString;
          leadingScrollOffset += t3;
        } else {
          leadingScrollOffset = 0;
          onlySlivers = false;
        }
      }
      if (pivot != null) {
        t1 = pivot.get$parent(pivot);
        t1.toString;
        type$.RenderSliver._as(t1);
        growthDirection = type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(t1)).growthDirection;
        switch (B.axisDirectionToAxis(_this._viewport$_axisDirection).index) {
          case 0:
            pivotExtent = pivot._size._dx;
            break;
          case 1:
            pivotExtent = pivot._size._dy;
            break;
          default:
            pivotExtent = _null;
        }
        if (rect == null)
          rect = target.get$paintBounds();
        rectLocal = B.MatrixUtils_transformRect(target.getTransformTo$1(0, pivot), rect);
      } else {
        if (onlySlivers) {
          type$.RenderSliver._as(target);
          t1 = type$.SliverConstraints;
          growthDirection = t1._as(B.RenderObject.prototype.get$constraints.call(target)).growthDirection;
          pivotExtent = target._geometry.scrollExtent;
          if (rect == null)
            switch (B.axisDirectionToAxis(_this._viewport$_axisDirection).index) {
              case 0:
                rect = new B.Rect(0, 0, 0 + pivotExtent, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(target)).crossAxisExtent);
                break;
              case 1:
                rect = new B.Rect(0, 0, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(target)).crossAxisExtent, 0 + target._geometry.scrollExtent);
                break;
            }
        } else {
          t1 = _this._viewport$_offset._pixels;
          t1.toString;
          rect.toString;
          return new D.RevealedOffset(t1, rect);
        }
        rectLocal = rect;
      }
      type$.RenderSliver._as(child);
      switch (B.applyGrowthDirectionToAxisDirection(_this._viewport$_axisDirection, growthDirection)) {
        case C.AxisDirection_0:
          t1 = rectLocal.bottom;
          leadingScrollOffset += pivotExtent - t1;
          targetMainAxisExtent = t1 - rectLocal.top;
          break;
        case C.AxisDirection_1:
          t1 = rectLocal.left;
          leadingScrollOffset += t1;
          targetMainAxisExtent = rectLocal.right - t1;
          break;
        case C.AxisDirection_2:
          t1 = rectLocal.top;
          leadingScrollOffset += t1;
          targetMainAxisExtent = rectLocal.bottom - t1;
          break;
        case C.AxisDirection_3:
          t1 = rectLocal.right;
          leadingScrollOffset += pivotExtent - t1;
          targetMainAxisExtent = t1 - rectLocal.left;
          break;
        default:
          targetMainAxisExtent = _null;
      }
      child._geometry.toString;
      leadingScrollOffset = _this.scrollOffsetOf$2(child, leadingScrollOffset);
      targetRect = B.MatrixUtils_transformRect(target.getTransformTo$1(0, _this), rect);
      extentOfPinnedSlivers = _this.maxScrollObstructionExtentBefore$1(child);
      switch (type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection.index) {
        case 0:
          leadingScrollOffset -= extentOfPinnedSlivers;
          break;
        case 1:
          switch (B.axisDirectionToAxis(_this._viewport$_axisDirection).index) {
            case 1:
              leadingScrollOffset -= targetRect.bottom - targetRect.top;
              break;
            case 0:
              leadingScrollOffset -= targetRect.right - targetRect.left;
              break;
          }
          break;
      }
      t1 = _this._viewport$_axisDirection;
      switch (B.axisDirectionToAxis(t1).index) {
        case 0:
          mainAxisExtent = _this._size._dx - extentOfPinnedSlivers;
          break;
        case 1:
          mainAxisExtent = _this._size._dy - extentOfPinnedSlivers;
          break;
        default:
          mainAxisExtent = _null;
      }
      targetOffset = leadingScrollOffset - (mainAxisExtent - targetMainAxisExtent) * alignment;
      t2 = _this._viewport$_offset._pixels;
      t2.toString;
      offsetDifference = t2 - targetOffset;
      switch (t1.index) {
        case 2:
          targetRect = targetRect.translate$2(0, 0, offsetDifference);
          break;
        case 1:
          targetRect = targetRect.translate$2(0, offsetDifference, 0);
          break;
        case 0:
          targetRect = targetRect.translate$2(0, 0, -offsetDifference);
          break;
        case 3:
          targetRect = targetRect.translate$2(0, -offsetDifference, 0);
          break;
      }
      return new D.RevealedOffset(targetOffset, targetRect);
    },
    computeAbsolutePaintOffset$3(child, layoutOffset, growthDirection) {
      switch (B.applyGrowthDirectionToAxisDirection(this._viewport$_axisDirection, growthDirection)) {
        case C.AxisDirection_0:
          return new B.Offset(0, this._size._dy - (layoutOffset + child._geometry.paintExtent));
        case C.AxisDirection_1:
          return new B.Offset(layoutOffset, 0);
        case C.AxisDirection_2:
          return new B.Offset(0, layoutOffset);
        case C.AxisDirection_3:
          return new B.Offset(this._size._dx - (layoutOffset + child._geometry.paintExtent), 0);
      }
    },
    debugDescribeChildren$0() {
      var count, t1, t2, _this = this,
        children = B._setArrayType([], type$.JSArray_DiagnosticsNode),
        child = _this.ContainerRenderObjectMixin__firstChild;
      if (child == null)
        return children;
      count = _this.get$indexOfFirstChild();
      for (t1 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"); true;) {
        child.toString;
        children.push(new B.DiagnosticableTreeNode(child, _this.labelForChild$1(count), true, true, null, null));
        if (child === _this.ContainerRenderObjectMixin__lastChild)
          break;
        ++count;
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
      return children;
    },
    showOnScreen$4$curve$descendant$duration$rect(curve, descendant, duration, rect) {
      var _this = this;
      if (!_this._viewport$_offset.physics.get$allowImplicitScrolling())
        return _this.super$RenderObject$showOnScreen(curve, descendant, duration, rect);
      _this.super$RenderObject$showOnScreen(curve, null, duration, D.RenderViewportBase_showInViewport(curve, descendant, duration, _this._viewport$_offset, rect, _this));
    },
    showOnScreen$0() {
      return this.showOnScreen$4$curve$descendant$duration$rect(C.Cubic_JUR, null, C.Duration_0, null);
    },
    showOnScreen$2$descendant$rect(descendant, rect) {
      return this.showOnScreen$4$curve$descendant$duration$rect(C.Cubic_JUR, descendant, C.Duration_0, rect);
    },
    showOnScreen$1$rect(rect) {
      return this.showOnScreen$4$curve$descendant$duration$rect(C.Cubic_JUR, null, C.Duration_0, rect);
    },
    showOnScreen$3$curve$duration$rect(curve, duration, rect) {
      return this.showOnScreen$4$curve$descendant$duration$rect(curve, null, duration, rect);
    },
    $isRenderAbstractViewport: 1
  };
  A.RenderViewport.prototype = {
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverPhysicalContainerParentData))
        child.parentData = new A.SliverPhysicalContainerParentData(null, null, C.Offset_0_0);
    },
    set$anchor(value) {
      if (value === this._anchor)
        return;
      this._anchor = value;
      this.markNeedsLayout$0();
    },
    set$center(value) {
      if (value == this._center)
        return;
      this._center = value;
      this.markNeedsLayout$0();
    },
    get$sizedByParent() {
      return true;
    },
    computeDryLayout$1(constraints) {
      return new B.Size(B.clampDouble(1 / 0, constraints.minWidth, constraints.maxWidth), B.clampDouble(1 / 0, constraints.minHeight, constraints.maxHeight));
    },
    performLayout$0() {
      var t1, mainAxisExtent, crossAxisExtent, t2, correction, t3, t4, t5, count, _this = this;
      switch (B.axisDirectionToAxis(_this._viewport$_axisDirection).index) {
        case 1:
          _this._viewport$_offset.applyViewportDimension$1(_this._size._dy);
          break;
        case 0:
          _this._viewport$_offset.applyViewportDimension$1(_this._size._dx);
          break;
      }
      if (_this._center == null) {
        _this.__RenderViewport__maxScrollExtent_A = _this.__RenderViewport__minScrollExtent_A = 0;
        _this._viewport$_hasVisualOverflow = false;
        _this._viewport$_offset.applyContentDimensions$2(0, 0);
        return;
      }
      switch (B.axisDirectionToAxis(_this._viewport$_axisDirection).index) {
        case 1:
          t1 = _this._size;
          mainAxisExtent = t1._dy;
          crossAxisExtent = t1._dx;
          break;
        case 0:
          t1 = _this._size;
          mainAxisExtent = t1._dx;
          crossAxisExtent = t1._dy;
          break;
        default:
          mainAxisExtent = null;
          crossAxisExtent = null;
      }
      t1 = 0;
      do {
        t2 = _this._viewport$_offset._pixels;
        t2.toString;
        correction = _this._attemptLayout$3(mainAxisExtent, crossAxisExtent, t2 + 0);
        if (correction !== 0)
          _this._viewport$_offset.correctBy$1(correction);
        else {
          t2 = _this._viewport$_offset;
          t3 = _this.__RenderViewport__minScrollExtent_A;
          t3 === $ && B.throwUnnamedLateFieldNI();
          t4 = _this._anchor;
          t3 = Math.min(0, t3 + mainAxisExtent * t4);
          t5 = _this.__RenderViewport__maxScrollExtent_A;
          t5 === $ && B.throwUnnamedLateFieldNI();
          if (t2.applyContentDimensions$2(t3, Math.max(0, t5 - mainAxisExtent * (1 - t4))))
            break;
        }
        count = t1 + 1;
        if (count < 10) {
          t1 = count;
          continue;
        } else
          break;
      } while (true);
    },
    _attemptLayout$3(mainAxisExtent, crossAxisExtent, correctedOffset) {
      var centerOffset, reverseDirectionRemainingPaintExtent, t1, forwardDirectionRemainingPaintExtent, t2, fullCacheExtent, centerCacheOffset, reverseDirectionRemainingCacheExtent, forwardDirectionRemainingCacheExtent, t3, leadingNegativeChild, t4, result, t5, _this = this;
      _this.__RenderViewport__maxScrollExtent_A = _this.__RenderViewport__minScrollExtent_A = 0;
      _this._viewport$_hasVisualOverflow = false;
      centerOffset = mainAxisExtent * _this._anchor - correctedOffset;
      reverseDirectionRemainingPaintExtent = B.clampDouble(centerOffset, 0, mainAxisExtent);
      t1 = mainAxisExtent - centerOffset;
      forwardDirectionRemainingPaintExtent = B.clampDouble(t1, 0, mainAxisExtent);
      switch (_this._cacheExtentStyle.index) {
        case 0:
          _this._calculatedCacheExtent = _this._cacheExtent;
          break;
        case 1:
          _this._calculatedCacheExtent = mainAxisExtent * _this._cacheExtent;
          break;
      }
      t2 = _this._calculatedCacheExtent;
      t2.toString;
      fullCacheExtent = mainAxisExtent + 2 * t2;
      centerCacheOffset = centerOffset + t2;
      reverseDirectionRemainingCacheExtent = B.clampDouble(centerCacheOffset, 0, fullCacheExtent);
      forwardDirectionRemainingCacheExtent = B.clampDouble(fullCacheExtent - centerCacheOffset, 0, fullCacheExtent);
      t3 = _this._center.parentData;
      t3.toString;
      leadingNegativeChild = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1")._as(t3).ContainerParentDataMixin_previousSibling;
      t3 = leadingNegativeChild == null;
      if (!t3) {
        t4 = Math.max(mainAxisExtent, centerOffset);
        result = _this.layoutChildSequence$11$advance$cacheOrigin$child$crossAxisExtent$growthDirection$layoutOffset$mainAxisExtent$overlap$remainingCacheExtent$remainingPaintExtent$scrollOffset(_this.get$childBefore(), B.clampDouble(t1, -t2, 0), leadingNegativeChild, crossAxisExtent, C.GrowthDirection_1, forwardDirectionRemainingPaintExtent, mainAxisExtent, 0, reverseDirectionRemainingCacheExtent, reverseDirectionRemainingPaintExtent, t4 - mainAxisExtent);
        if (result !== 0)
          return -result;
      }
      t1 = _this._center;
      t2 = -centerOffset;
      t4 = Math.max(0, t2);
      t2 = t3 ? Math.min(0, t2) : 0;
      t3 = centerOffset >= mainAxisExtent ? centerOffset : reverseDirectionRemainingPaintExtent;
      t5 = _this._calculatedCacheExtent;
      t5.toString;
      return _this.layoutChildSequence$11$advance$cacheOrigin$child$crossAxisExtent$growthDirection$layoutOffset$mainAxisExtent$overlap$remainingCacheExtent$remainingPaintExtent$scrollOffset(_this.get$childAfter(), B.clampDouble(centerOffset, -t5, 0), t1, crossAxisExtent, C.GrowthDirection_0, t3, mainAxisExtent, t2, forwardDirectionRemainingCacheExtent, forwardDirectionRemainingPaintExtent, t4);
    },
    get$hasVisualOverflow() {
      return this._viewport$_hasVisualOverflow;
    },
    updateOutOfBandData$2(growthDirection, childLayoutGeometry) {
      var t1, _this = this;
      switch (growthDirection.index) {
        case 0:
          t1 = _this.__RenderViewport__maxScrollExtent_A;
          t1 === $ && B.throwUnnamedLateFieldNI();
          _this.__RenderViewport__maxScrollExtent_A = t1 + childLayoutGeometry.scrollExtent;
          break;
        case 1:
          t1 = _this.__RenderViewport__minScrollExtent_A;
          t1 === $ && B.throwUnnamedLateFieldNI();
          _this.__RenderViewport__minScrollExtent_A = t1 - childLayoutGeometry.scrollExtent;
          break;
      }
      if (childLayoutGeometry.hasVisualOverflow)
        _this._viewport$_hasVisualOverflow = true;
    },
    updateChildLayoutOffset$3(child, layoutOffset, growthDirection) {
      var t1 = child.parentData;
      t1.toString;
      type$.SliverPhysicalParentData._as(t1).paintOffset = this.computeAbsolutePaintOffset$3(child, layoutOffset, growthDirection);
    },
    paintOffsetOf$1(child) {
      var t1 = child.parentData;
      t1.toString;
      return type$.SliverPhysicalParentData._as(t1).paintOffset;
    },
    scrollOffsetOf$2(child, scrollOffsetWithinChild) {
      var current, t1, scrollOffsetToChild, t2, _this = this;
      switch (type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection.index) {
        case 0:
          current = _this._center;
          for (t1 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"), scrollOffsetToChild = 0; current !== child;) {
            scrollOffsetToChild += current._geometry.scrollExtent;
            t2 = current.parentData;
            t2.toString;
            current = t1._as(t2).ContainerParentDataMixin_nextSibling;
          }
          return scrollOffsetToChild + scrollOffsetWithinChild;
        case 1:
          t1 = _this._center.parentData;
          t1.toString;
          t2 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1");
          current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          for (scrollOffsetToChild = 0; current !== child;) {
            scrollOffsetToChild -= current._geometry.scrollExtent;
            t1 = current.parentData;
            t1.toString;
            current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          }
          return scrollOffsetToChild - scrollOffsetWithinChild;
      }
    },
    maxScrollObstructionExtentBefore$1(child) {
      var current, t1, t2, _this = this;
      switch (type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection.index) {
        case 0:
          current = _this._center;
          for (t1 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"); current !== child;) {
            current._geometry.toString;
            t2 = current.parentData;
            t2.toString;
            current = t1._as(t2).ContainerParentDataMixin_nextSibling;
          }
          return 0;
        case 1:
          t1 = _this._center.parentData;
          t1.toString;
          t2 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1");
          current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          for (; current !== child;) {
            current._geometry.toString;
            t1 = current.parentData;
            t1.toString;
            current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          }
          return 0;
      }
    },
    applyPaintTransform$2(child, transform) {
      var t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverPhysicalParentData._as(t1).paintOffset;
      transform.translate$2(0, t1._dx, t1._dy);
    },
    computeChildMainAxisPosition$2(child, parentMainAxisPosition) {
      var t2,
        t1 = child.parentData;
      t1.toString;
      type$.SliverPhysicalParentData._as(t1);
      t2 = type$.SliverConstraints;
      switch (B.applyGrowthDirectionToAxisDirection(t2._as(B.RenderObject.prototype.get$constraints.call(child)).axisDirection, t2._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection)) {
        case C.AxisDirection_2:
          return parentMainAxisPosition - t1.paintOffset._dy;
        case C.AxisDirection_1:
          return parentMainAxisPosition - t1.paintOffset._dx;
        case C.AxisDirection_0:
          return child._geometry.paintExtent - (parentMainAxisPosition - t1.paintOffset._dy);
        case C.AxisDirection_3:
          return child._geometry.paintExtent - (parentMainAxisPosition - t1.paintOffset._dx);
      }
    },
    get$indexOfFirstChild() {
      var t1, t2, count, t3,
        child = this._center;
      for (t1 = this.ContainerRenderObjectMixin__firstChild, t2 = B._instanceType(this)._eval$1("ContainerRenderObjectMixin.1"), count = 0; child != t1;) {
        --count;
        t3 = child.parentData;
        t3.toString;
        child = t2._as(t3).ContainerParentDataMixin_previousSibling;
      }
      return count;
    },
    labelForChild$1(index) {
      if (index === 0)
        return "center child";
      return "child " + index;
    },
    get$childrenInPaintOrder() {
      var t1, t2, _this = this,
        children = B._setArrayType([], type$.JSArray_RenderSliver),
        child = _this.ContainerRenderObjectMixin__firstChild;
      if (child == null)
        return children;
      for (t1 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"); child != _this._center;) {
        child.toString;
        children.push(child);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
      child = _this.ContainerRenderObjectMixin__lastChild;
      for (; true;) {
        child.toString;
        children.push(child);
        if (child === _this._center)
          return children;
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_previousSibling;
      }
    },
    get$childrenInHitTestOrder() {
      var child, t1, t2, _this = this,
        children = B._setArrayType([], type$.JSArray_RenderSliver);
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        return children;
      child = _this._center;
      for (t1 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1"); child != null;) {
        children.push(child);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
      t2 = _this._center.parentData;
      t2.toString;
      child = t1._as(t2).ContainerParentDataMixin_previousSibling;
      for (; child != null;) {
        children.push(child);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_previousSibling;
      }
      return children;
    }
  };
  A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin.prototype = {
    attach$1(owner) {
      var child, t1, t2;
      this.super$RenderObject$attach(owner);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this)._eval$1("_RenderViewportBase_RenderBox_ContainerRenderObjectMixin.0"); child != null;) {
        child.attach$1(owner);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    },
    detach$0(_) {
      var child, t1, t2;
      this.super$AbstractNode$detach(0);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this)._eval$1("_RenderViewportBase_RenderBox_ContainerRenderObjectMixin.0"); child != null;) {
        child.detach$0(0);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    }
  };
  A.AutomaticKeepAlive.prototype = {
    createState$0() {
      return new A._AutomaticKeepAliveState(C._StateLifecycle_0);
    }
  };
  A._AutomaticKeepAliveState.prototype = {
    initState$0() {
      this.super$State$initState();
      this._updateChild$0();
    },
    didUpdateWidget$1(oldWidget) {
      this.super$State$didUpdateWidget(oldWidget);
      this._updateChild$0();
    },
    _updateChild$0() {
      this.___AutomaticKeepAliveState__child_A = new B.NotificationListener(this.get$_addClient(), this._widget.child, null, type$.NotificationListener_KeepAliveNotification);
    },
    dispose$0() {
      var t2, t3,
        t1 = this._handles;
      if (t1 != null)
        for (t1 = B.LinkedHashMapKeyIterator$(t1, t1._modifications, B._instanceType(t1)._precomputed1); t1.moveNext$0();) {
          t2 = t1.__js_helper$_current;
          t3 = this._handles.$index(0, t2);
          t3.toString;
          t2.removeListener$1(0, t3);
        }
      this.super$State$dispose();
    },
    _addClient$1(notification) {
      var childElement, _this = this,
        handle = notification.handle,
        t1 = _this._handles;
      if (t1 == null)
        t1 = _this._handles = B.LinkedHashMap_LinkedHashMap$_empty(type$.Listenable, type$.void_Function);
      t1.$indexSet(0, handle, _this._createCallback$1(handle));
      t1 = _this._handles.$index(0, handle);
      t1.toString;
      handle.addListener$1(0, t1);
      if (!_this._keepingAlive) {
        _this._keepingAlive = true;
        childElement = _this._getChildElement$0();
        if (childElement != null)
          _this._updateParentDataOfChild$1(childElement);
        else
          $.SchedulerBinding__instance.SchedulerBinding__postFrameCallbacks.push(new A._AutomaticKeepAliveState__addClient_closure(_this));
      }
      return false;
    },
    _getChildElement$0() {
      var t1 = {},
        t2 = this._framework$_element;
      t2.toString;
      t1.childElement = null;
      t2.visitChildren$1(new A._AutomaticKeepAliveState__getChildElement_closure(t1));
      return type$.nullable_ParentDataElement_KeepAliveParentDataMixin._as(t1.childElement);
    },
    _updateParentDataOfChild$1(childElement) {
      var t1, t2;
      this._framework$_element.toString;
      t1 = this._keepingAlive;
      t2 = this.___AutomaticKeepAliveState__child_A;
      t2 === $ && B.throwUnnamedLateFieldNI();
      childElement._applyParentData$1(type$.ParentDataWidget_KeepAliveParentDataMixin._as(A.KeepAlive$(t2, t1)));
    },
    _createCallback$1(handle) {
      return new A._AutomaticKeepAliveState__createCallback_closure(this, handle);
    },
    build$1(context) {
      var t1 = this._keepingAlive,
        t2 = this.___AutomaticKeepAliveState__child_A;
      t2 === $ && B.throwUnnamedLateFieldNI();
      return new A.KeepAlive(t1, t2, null);
    }
  };
  A.IndexedSemantics.prototype = {
    createRenderObject$1(context) {
      var t1 = new A.RenderIndexedSemantics(this.index, null, B.LayerHandle$(type$.ContainerLayer));
      t1.RenderObject$0();
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2(context, renderObject) {
      renderObject.set$index(0, this.index);
    }
  };
  A.NeverScrollableScrollPhysics.prototype = {
    applyTo$1(ancestor) {
      return new A.NeverScrollableScrollPhysics(this.buildParent$1(ancestor));
    },
    shouldAcceptUserOffset$1(position) {
      return false;
    },
    get$allowImplicitScrolling() {
      return false;
    }
  };
  A.SliverChildDelegate.prototype = {
    get$estimatedChildCount() {
      return null;
    },
    toString$0(_) {
      var description = B._setArrayType([], type$.JSArray_String);
      this.debugFillDescription$1(description);
      return "<optimized out>#" + B.shortHash(this) + "(" + C.JSArray_methods.join$1(description, ", ") + ")";
    },
    debugFillDescription$1(description) {
      var children, e, exception;
      try {
        children = this.get$estimatedChildCount();
        if (children != null)
          description.push("estimated child count: " + B.S(children));
      } catch (exception) {
        e = B.unwrapException(exception);
        description.push("estimated child count: EXCEPTION (" + J.get$runtimeType$(e).toString$0(0) + ")");
      }
    }
  };
  A._SaltedValueKey.prototype = {};
  A._SelectionKeepAlive.prototype = {
    createState$0() {
      return new A._SelectionKeepAliveState(null, C._StateLifecycle_0);
    }
  };
  A._SelectionKeepAliveState.prototype = {
    get$wantKeepAlive() {
      return this._wantKeepAlive;
    },
    listensTo$1(selectable) {
      return new A._SelectionKeepAliveState_listensTo_closure(this, selectable);
    },
    _updateSelectablesWithSelections$2$add(selectable, add) {
      var t1, _this = this;
      if (add) {
        t1 = _this._selectablesWithSelections;
        (t1 == null ? _this._selectablesWithSelections = B.LinkedHashSet_LinkedHashSet$_empty(type$.Selectable) : t1).add$1(0, selectable);
      } else {
        t1 = _this._selectablesWithSelections;
        if (t1 != null)
          t1.remove$1(0, selectable);
      }
      t1 = _this._selectablesWithSelections;
      t1 = t1 == null ? null : t1._collection$_length !== 0;
      t1 = t1 === true;
      if (_this._wantKeepAlive !== t1) {
        _this._wantKeepAlive = t1;
        _this.updateKeepAlive$0();
      }
    },
    didChangeDependencies$0() {
      var t1, newRegistrar, t2, _this = this;
      _this.super$State$didChangeDependencies();
      t1 = _this._framework$_element;
      t1.toString;
      newRegistrar = B.SelectionContainer_maybeOf(t1);
      t1 = _this._sliver$_registrar;
      if (t1 != newRegistrar) {
        if (t1 != null) {
          t2 = _this._selectableAttachments;
          if (t2 != null)
            new B.LinkedHashMapKeyIterable(t2, B._instanceType(t2)._eval$1("LinkedHashMapKeyIterable<1>")).forEach$1(0, t1.get$remove(t1));
        }
        _this._sliver$_registrar = newRegistrar;
        if (newRegistrar != null) {
          t1 = _this._selectableAttachments;
          if (t1 != null)
            new B.LinkedHashMapKeyIterable(t1, B._instanceType(t1)._eval$1("LinkedHashMapKeyIterable<1>")).forEach$1(0, newRegistrar.get$add(newRegistrar));
        }
      }
    },
    add$1(_, selectable) {
      var t1, _this = this,
        attachment = _this.listensTo$1(selectable);
      selectable.addListener$1(0, attachment);
      t1 = _this._selectableAttachments;
      (t1 == null ? _this._selectableAttachments = B.LinkedHashMap_LinkedHashMap$_empty(type$.Selectable, type$.void_Function) : t1).$indexSet(0, selectable, attachment);
      _this._sliver$_registrar.add$1(0, selectable);
      if (selectable.get$value(selectable).status !== C.SelectionStatus_2)
        _this._updateSelectablesWithSelections$2$add(selectable, true);
    },
    remove$1(_, selectable) {
      var t1 = this._selectableAttachments;
      if (t1 == null)
        return;
      t1 = t1.remove$1(0, selectable);
      t1.toString;
      selectable.removeListener$1(0, t1);
      this._sliver$_registrar.remove$1(0, selectable);
      this._updateSelectablesWithSelections$2$add(selectable, false);
    },
    dispose$0() {
      var t2, t3, _this = this,
        t1 = _this._selectableAttachments;
      if (t1 != null) {
        for (t1 = B.LinkedHashMapKeyIterator$(t1, t1._modifications, B._instanceType(t1)._precomputed1); t1.moveNext$0();) {
          t2 = t1.__js_helper$_current;
          _this._sliver$_registrar.remove$1(0, t2);
          t3 = _this._selectableAttachments.$index(0, t2);
          t3.toString;
          t2.removeListener$1(0, t3);
        }
        _this._selectableAttachments = null;
      }
      _this._selectablesWithSelections = null;
      _this.super$State$dispose();
    },
    build$1(context) {
      var _this = this;
      _this.super$AutomaticKeepAliveClientMixin$build(context);
      if (_this._sliver$_registrar == null)
        return _this._widget.child;
      return D.SelectionRegistrarScope$(_this._widget.child, _this);
    }
  };
  A.SliverWithKeepAliveWidget.prototype = {};
  A.SliverMultiBoxAdaptorWidget.prototype = {
    createElement$0(_) {
      return A.SliverMultiBoxAdaptorElement$(this, false);
    }
  };
  A.SliverMultiBoxAdaptorElement.prototype = {
    get$renderObject() {
      return type$.RenderSliverMultiBoxAdaptor._as(B.RenderObjectElement.prototype.get$renderObject.call(this));
    },
    update$1(_, newWidget) {
      var newDelegate, oldDelegate,
        t1 = this._widget;
      t1.toString;
      type$.SliverMultiBoxAdaptorWidget._as(t1);
      this.super$RenderObjectElement$update(0, newWidget);
      newDelegate = newWidget.delegate;
      oldDelegate = t1.delegate;
      if (newDelegate !== oldDelegate)
        t1 = B.getRuntimeType(newDelegate) !== B.getRuntimeType(oldDelegate) || newDelegate.shouldRebuild$1(oldDelegate);
      else
        t1 = false;
      if (t1)
        this.performRebuild$0();
    },
    performRebuild$0() {
      var newChildren, indexToLayoutOffset, adaptorWidget, processElement, index, key, newIndex, childParentData, lastKey, rightBoundary, t1, t2, t3, t4, t5, _i, t6, lastKey0, _this = this, _box_0 = {};
      _this.super$RenderObjectElement$performRebuild();
      _this._currentBeforeChild = null;
      _box_0.childrenUpdated = false;
      try {
        t1 = type$.int;
        newChildren = D.SplayTreeMap$(t1, type$.nullable_Element);
        indexToLayoutOffset = B.HashMap_HashMap(t1, type$.double);
        t1 = _this._widget;
        t1.toString;
        adaptorWidget = type$.SliverMultiBoxAdaptorWidget._as(t1);
        processElement = new A.SliverMultiBoxAdaptorElement_performRebuild_processElement(_box_0, _this, newChildren, adaptorWidget, indexToLayoutOffset);
        for (t1 = _this._childElements, t2 = t1.$ti, t2 = t2._eval$1("@<1>")._bind$1(t2._eval$1("_SplayTreeMapNode<1,2>"))._eval$1("_SplayTreeKeyIterable<1,2>"), t2 = B.List_List$of(new D._SplayTreeKeyIterable(t1, t2), true, t2._eval$1("Iterable.E")), t3 = t2.length, t4 = type$.nullable_SliverMultiBoxAdaptorParentData, t5 = _this._replaceMovedChildren, _i = 0; _i < t3; ++_i) {
          index = t2[_i];
          key = t1.$index(0, index)._widget.key;
          newIndex = key == null ? null : adaptorWidget.delegate.findIndexByKey$1(key);
          t6 = t1.$index(0, index).get$renderObject();
          childParentData = t4._as(t6 == null ? null : t6.parentData);
          if (childParentData != null && childParentData.layoutOffset != null) {
            t6 = childParentData.layoutOffset;
            t6.toString;
            J.$indexSet$ax(indexToLayoutOffset, index, t6);
          }
          if (newIndex != null && !J.$eq$(newIndex, index)) {
            if (childParentData != null)
              childParentData.layoutOffset = null;
            J.$indexSet$ax(newChildren, newIndex, t1.$index(0, index));
            if (t5)
              J.putIfAbsent$2$x(newChildren, index, new A.SliverMultiBoxAdaptorElement_performRebuild_closure());
            t1.remove$1(0, index);
          } else
            J.putIfAbsent$2$x(newChildren, index, new A.SliverMultiBoxAdaptorElement_performRebuild_closure0(_this, index));
        }
        _this.get$renderObject();
        t2 = newChildren;
        t3 = B.instanceType(t2);
        new D._SplayTreeKeyIterable(t2, t3._eval$1("@<1>")._bind$1(t3._eval$1("_SplayTreeMapNode<1,2>"))._eval$1("_SplayTreeKeyIterable<1,2>")).forEach$1(0, processElement);
        if (!_box_0.childrenUpdated && _this._didUnderflow) {
          lastKey0 = t1.lastKey$0();
          lastKey = lastKey0 == null ? -1 : lastKey0;
          rightBoundary = lastKey + 1;
          J.$indexSet$ax(newChildren, rightBoundary, t1.$index(0, rightBoundary));
          processElement.call$1(rightBoundary);
        }
      } finally {
        _this._currentlyUpdatingChildIndex = null;
        _this.get$renderObject();
      }
    },
    createChild$2$after(index, after) {
      this._owner.buildScope$2(this, new A.SliverMultiBoxAdaptorElement_createChild_closure(this, after, index));
    },
    updateChild$3(child, newWidget, newSlot) {
      var t1, t2, newChild, t3, _null = null;
      if (child == null)
        t1 = _null;
      else {
        t1 = child.get$renderObject();
        t1 = t1 == null ? _null : t1.parentData;
      }
      t2 = type$.nullable_SliverMultiBoxAdaptorParentData;
      t2._as(t1);
      newChild = this.super$Element$updateChild(child, newWidget, newSlot);
      if (newChild == null)
        t3 = _null;
      else {
        t3 = newChild.get$renderObject();
        t3 = t3 == null ? _null : t3.parentData;
      }
      t2._as(t3);
      if (t1 != t3 && t1 != null && t3 != null)
        t3.layoutOffset = t1.layoutOffset;
      return newChild;
    },
    forgetChild$1(child) {
      this._childElements.remove$1(0, child._slot);
      this.super$Element$forgetChild(child);
    },
    removeChild$1(child) {
      var t1, _this = this;
      _this.get$renderObject();
      t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverMultiBoxAdaptorParentData._as(t1).index;
      t1.toString;
      _this._owner.buildScope$2(_this, new A.SliverMultiBoxAdaptorElement_removeChild_closure(_this, t1));
    },
    estimateMaxScrollOffset$5$firstIndex$lastIndex$leadingScrollOffset$trailingScrollOffset(constraints, firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset) {
      var t2, childCount,
        t1 = this._widget;
      t1.toString;
      t2 = type$.SliverMultiBoxAdaptorWidget;
      childCount = t2._as(t1).delegate.get$estimatedChildCount();
      t1 = this._widget;
      t1.toString;
      t2._as(t1);
      leadingScrollOffset.toString;
      t1 = A.SliverMultiBoxAdaptorElement__extrapolateMaxScrollOffset(firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset, childCount);
      return t1;
    },
    get$childCount() {
      var result,
        t1 = this._widget;
      t1.toString;
      result = type$.SliverMultiBoxAdaptorWidget._as(t1).delegate.get$estimatedChildCount();
      return result;
    },
    didFinishLayout$0() {
      var t1 = this._childElements;
      t1.firstKey$0();
      t1.lastKey$0();
      t1 = this._widget;
      t1.toString;
      type$.SliverMultiBoxAdaptorWidget._as(t1);
    },
    didAdoptChild$1(child) {
      var t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1).index = this._currentlyUpdatingChildIndex;
    },
    insertRenderObjectChild$2(child, slot) {
      this.get$renderObject().super$ContainerRenderObjectMixin$insert(0, type$.RenderBox._as(child), this._currentBeforeChild);
    },
    moveRenderObjectChild$3(child, oldSlot, newSlot) {
      this.get$renderObject().move$2$after(type$.RenderBox._as(child), this._currentBeforeChild);
    },
    removeRenderObjectChild$2(child, slot) {
      this.get$renderObject().remove$1(0, type$.RenderBox._as(child));
    },
    visitChildren$1(visitor) {
      var t1 = this._childElements,
        t2 = t1.$ti;
      t2 = t2._eval$1("@<1>")._bind$1(t2._rest[1])._eval$1("_SplayTreeValueIterable<1,2>");
      t2 = B.CastIterable_CastIterable(new D._SplayTreeValueIterable(t1, t2), t2._eval$1("Iterable.E"), type$.Element);
      C.JSArray_methods.forEach$1(B.List_List$of(t2, true, B._instanceType(t2)._eval$1("Iterable.E")), visitor);
    }
  };
  A.KeepAlive.prototype = {
    applyParentData$1(renderObject) {
      var t2, targetParent,
        t1 = renderObject.parentData;
      t1.toString;
      type$.KeepAliveParentDataMixin._as(t1);
      t2 = this.keepAlive;
      if (t1.KeepAliveParentDataMixin_keepAlive !== t2) {
        t1.KeepAliveParentDataMixin_keepAlive = t2;
        targetParent = renderObject.get$parent(renderObject);
        if (targetParent instanceof B.RenderObject && !t2)
          targetParent.markNeedsLayout$0();
      }
    }
  };
  A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin.prototype = {
    initState$0() {
      this.super$State$initState();
      if (this._wantKeepAlive)
        this._ensureKeepAlive$0();
    },
    deactivate$0() {
      var t1 = this.AutomaticKeepAliveClientMixin__keepAliveHandle;
      if (t1 != null) {
        t1.notifyListeners$0();
        this.AutomaticKeepAliveClientMixin__keepAliveHandle = null;
      }
      this.super$State$deactivate();
    }
  };
  A.Viewport.prototype = {
    createRenderObject$1(context) {
      var _this = this,
        t1 = _this.axisDirection,
        t2 = A.Viewport_getDefaultCrossAxisDirection(context, t1),
        t3 = _this.cacheExtent,
        t4 = B.LayerHandle$(type$.ClipRectLayer);
      if (t3 == null)
        t3 = 250;
      t4 = new A.RenderViewport(_this.anchor, t1, t2, _this.offset, t3, _this.cacheExtentStyle, _this.clipBehavior, t4, 0, null, null, B.LayerHandle$(type$.ContainerLayer));
      t4.RenderObject$0();
      t4.addAll$1(0, null);
      t1 = t4.ContainerRenderObjectMixin__firstChild;
      if (t1 != null)
        t4._center = t1;
      return t4;
    },
    updateRenderObject$2(context, renderObject) {
      var _this = this,
        t1 = _this.axisDirection;
      renderObject.set$axisDirection(t1);
      t1 = A.Viewport_getDefaultCrossAxisDirection(context, t1);
      renderObject.set$crossAxisDirection(t1);
      renderObject.set$anchor(_this.anchor);
      renderObject.set$offset(0, _this.offset);
      renderObject.set$cacheExtent(_this.cacheExtent);
      renderObject.set$cacheExtentStyle(_this.cacheExtentStyle);
      renderObject.set$clipBehavior(_this.clipBehavior);
    },
    createElement$0(_) {
      return new A._ViewportElement(B.HashSet_HashSet(type$.Element), this, C._ElementLifecycle_0);
    }
  };
  A._ViewportElement.prototype = {
    get$renderObject() {
      return type$.RenderViewport._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(this));
    },
    mount$2($parent, newSlot) {
      var _this = this;
      _this._viewport0$_doingMountOrUpdate = true;
      _this.super$MultiChildRenderObjectElement$mount($parent, newSlot);
      _this._updateCenter$0();
      _this._viewport0$_doingMountOrUpdate = false;
    },
    update$1(_, newWidget) {
      var _this = this;
      _this._viewport0$_doingMountOrUpdate = true;
      _this.super$MultiChildRenderObjectElement$update(0, newWidget);
      _this._updateCenter$0();
      _this._viewport0$_doingMountOrUpdate = false;
    },
    _updateCenter$0() {
      var t2, _this = this,
        t1 = _this._widget;
      t1.toString;
      type$.Viewport._as(t1);
      t1 = _this.get$children(_this);
      t2 = type$.RenderViewport;
      if (!t1.get$isEmpty(t1)) {
        t1 = t2._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this));
        t2 = _this.get$children(_this);
        t1.set$center(type$.nullable_RenderSliver._as(t2.get$first(t2).get$renderObject()));
        _this._centerSlotIndex = 0;
      } else {
        t2._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this)).set$center(null);
        _this._centerSlotIndex = null;
      }
    },
    insertRenderObjectChild$2(child, slot) {
      var _this = this;
      _this.super$MultiChildRenderObjectElement$insertRenderObjectChild(child, slot);
      if (!_this._viewport0$_doingMountOrUpdate && slot.index === _this._centerSlotIndex)
        type$.RenderViewport._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this)).set$center(type$.nullable_RenderSliver._as(child));
    },
    moveRenderObjectChild$3(child, oldSlot, newSlot) {
      this.super$MultiChildRenderObjectElement$moveRenderObjectChild(child, oldSlot, newSlot);
    },
    removeRenderObjectChild$2(child, slot) {
      var _this = this;
      _this.super$MultiChildRenderObjectElement$removeRenderObjectChild(child, slot);
      if (!_this._viewport0$_doingMountOrUpdate && type$.RenderViewport._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this))._center === child)
        type$.RenderViewport._as(B.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this)).set$center(null);
    }
  };
  A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin.prototype = {};
  A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin.prototype = {};
  var typesOffset = hunkHelpers.updateTypes(["~(SliverConstraints)", "~(Selectable)", "bool(SliverHitTestResult{crossAxisPosition!double,mainAxisPosition!double})", "~(PaintingContext,Offset)", "~({curve:Curve,descendant:RenderObject?,duration:Duration,rect:Rect?})", "bool(KeepAliveNotification)", "~(RenderBox)", "int(Widget,int)"]);
  A.RenderSliverHelpers_hitTestBoxChild_closure.prototype = {
    call$1(result) {
      return this.child.hitTest$2$position(result, this._box_0.transformedPosition);
    },
    $signature: 138
  };
  A.RenderSliverMultiBoxAdaptor__createOrObtainChild_closure.prototype = {
    call$1(constraints) {
      var t1 = this.$this,
        t2 = t1._keepAliveBucket,
        t3 = this.index,
        t4 = this.after;
      if (t2.containsKey$1(0, t3)) {
        t2 = t2.remove$1(0, t3);
        t2.toString;
        t3 = t2.parentData;
        t3.toString;
        type$.SliverMultiBoxAdaptorParentData._as(t3);
        t1.dropChild$1(t2);
        t2.parentData = t3;
        t1.super$ContainerRenderObjectMixin$insert(0, t2, t4);
        t3._keptAlive = false;
      } else
        t1._childManager.createChild$2$after(t3, t4);
    },
    $signature: typesOffset + 0
  };
  A.RenderSliverMultiBoxAdaptor_collectGarbage_closure.prototype = {
    call$1(constraints) {
      var t1, t2, t3;
      for (t1 = this._box_0, t2 = this.$this; t1.leadingGarbage > 0;) {
        t3 = t2.ContainerRenderObjectMixin__firstChild;
        t3.toString;
        t2._destroyOrCacheChild$1(t3);
        --t1.leadingGarbage;
      }
      for (; t1.trailingGarbage > 0;) {
        t3 = t2.ContainerRenderObjectMixin__lastChild;
        t3.toString;
        t2._destroyOrCacheChild$1(t3);
        --t1.trailingGarbage;
      }
      t1 = t2._keepAliveBucket;
      t1 = t1.get$values(t1);
      t3 = B._instanceType(t1)._eval$1("WhereIterable<Iterable.E>");
      C.JSArray_methods.forEach$1(B.List_List$of(new B.WhereIterable(t1, new A.RenderSliverMultiBoxAdaptor_collectGarbage__closure(), t3), true, t3._eval$1("Iterable.E")), t2._childManager.get$removeChild());
    },
    $signature: typesOffset + 0
  };
  A.RenderSliverMultiBoxAdaptor_collectGarbage__closure.prototype = {
    call$1(child) {
      var t1 = child.parentData;
      t1.toString;
      return !type$.SliverMultiBoxAdaptorParentData._as(t1).KeepAliveParentDataMixin_keepAlive;
    },
    $signature: 401
  };
  A.RenderViewportBase_visitChildrenForSemantics_closure.prototype = {
    call$1(sliver) {
      var t1 = sliver._geometry;
      return t1.visible || t1.cacheExtent > 0;
    },
    $signature: 402
  };
  A.RenderViewportBase_hitTestChildren_closure.prototype = {
    call$1(result) {
      var _this = this,
        t1 = _this.child,
        t2 = _this._box_0,
        t3 = _this.$this.computeChildMainAxisPosition$2(t1, t2.mainAxisPosition);
      return t1.hitTest$3$crossAxisPosition$mainAxisPosition(_this.sliverResult, t2.crossAxisPosition, t3);
    },
    $signature: 138
  };
  A._AutomaticKeepAliveState__addClient_closure.prototype = {
    call$1(timeStamp) {
      var childElement,
        t1 = this.$this;
      if (t1._framework$_element == null)
        return;
      childElement = t1._getChildElement$0();
      childElement.toString;
      t1._updateParentDataOfChild$1(childElement);
    },
    $signature: 2
  };
  A._AutomaticKeepAliveState__getChildElement_closure.prototype = {
    call$1(child) {
      this._box_0.childElement = child;
    },
    $signature: 5
  };
  A._AutomaticKeepAliveState__createCallback_closure.prototype = {
    call$0() {
      var t1 = this.$this;
      t1._handles.remove$1(0, this.handle);
      if (t1._handles._length === 0)
        if ($.SchedulerBinding__instance.SchedulerBinding__schedulerPhase.index < 3)
          t1.setState$1(new A._AutomaticKeepAliveState__createCallback__closure(t1));
        else {
          t1._keepingAlive = false;
          B.scheduleMicrotask(new A._AutomaticKeepAliveState__createCallback__closure0(t1));
        }
    },
    $signature: 0
  };
  A._AutomaticKeepAliveState__createCallback__closure.prototype = {
    call$0() {
      this.$this._keepingAlive = false;
    },
    $signature: 0
  };
  A._AutomaticKeepAliveState__createCallback__closure0.prototype = {
    call$0() {
      var t1 = this.$this;
      if (t1._framework$_element != null && t1._handles._length === 0)
        t1.setState$1(new A._AutomaticKeepAliveState__createCallback___closure(t1));
    },
    $signature: 0
  };
  A._AutomaticKeepAliveState__createCallback___closure.prototype = {
    call$0() {
    },
    $signature: 0
  };
  A._SelectionKeepAliveState_listensTo_closure.prototype = {
    call$0() {
      var t1 = this.selectable,
        t2 = this.$this;
      if (t1.get$value(t1).status !== C.SelectionStatus_2)
        t2._updateSelectablesWithSelections$2$add(t1, true);
      else
        t2._updateSelectablesWithSelections$2$add(t1, false);
    },
    $signature: 0
  };
  A.SliverMultiBoxAdaptorElement_performRebuild_processElement.prototype = {
    call$1(index) {
      var newChild, parentData, t2, t3, _this = this,
        t1 = _this.$this;
      t1._currentlyUpdatingChildIndex = index;
      t2 = t1._childElements;
      if (t2.$index(0, index) != null && !J.$eq$(t2.$index(0, index), _this.newChildren.$index(0, index))) {
        t2.$indexSet(0, index, t1.updateChild$3(t2.$index(0, index), null, index));
        _this._box_0.childrenUpdated = true;
      }
      newChild = t1.updateChild$3(_this.newChildren.$index(0, index), _this.adaptorWidget.delegate.build$2(t1, index), index);
      if (newChild != null) {
        t3 = _this._box_0;
        t3.childrenUpdated = t3.childrenUpdated || !J.$eq$(t2.$index(0, index), newChild);
        t2.$indexSet(0, index, newChild);
        t2 = newChild.get$renderObject().parentData;
        t2.toString;
        parentData = type$.SliverMultiBoxAdaptorParentData._as(t2);
        if (index === 0)
          parentData.layoutOffset = 0;
        else {
          t2 = _this.indexToLayoutOffset;
          if (t2.containsKey$1(0, index))
            parentData.layoutOffset = t2.$index(0, index);
        }
        if (!parentData._keptAlive)
          t1._currentBeforeChild = type$.nullable_RenderBox._as(newChild.get$renderObject());
      } else {
        _this._box_0.childrenUpdated = true;
        t2.remove$1(0, index);
      }
    },
    $signature: 27
  };
  A.SliverMultiBoxAdaptorElement_performRebuild_closure.prototype = {
    call$0() {
      return null;
    },
    $signature: 6
  };
  A.SliverMultiBoxAdaptorElement_performRebuild_closure0.prototype = {
    call$0() {
      return this.$this._childElements.$index(0, this.index);
    },
    $signature: 403
  };
  A.SliverMultiBoxAdaptorElement_createChild_closure.prototype = {
    call$0() {
      var newChild, adaptorWidget, t2, _this = this,
        t1 = _this.$this;
      t1._currentBeforeChild = _this.after == null ? null : type$.nullable_RenderBox._as(t1._childElements.$index(0, _this.index - 1).get$renderObject());
      newChild = null;
      try {
        t2 = t1._widget;
        t2.toString;
        adaptorWidget = type$.SliverMultiBoxAdaptorWidget._as(t2);
        t2 = t1._currentlyUpdatingChildIndex = _this.index;
        newChild = t1.updateChild$3(t1._childElements.$index(0, t2), adaptorWidget.delegate.build$2(t1, t2), t2);
      } finally {
        t1._currentlyUpdatingChildIndex = null;
      }
      t2 = _this.index;
      t1 = t1._childElements;
      if (newChild != null)
        t1.$indexSet(0, t2, newChild);
      else
        t1.remove$1(0, t2);
    },
    $signature: 0
  };
  A.SliverMultiBoxAdaptorElement_removeChild_closure.prototype = {
    call$0() {
      var result, t1, t2, _this = this;
      try {
        t1 = _this.$this;
        t2 = t1._currentlyUpdatingChildIndex = _this.index;
        result = t1.updateChild$3(t1._childElements.$index(0, t2), null, t2);
      } finally {
        _this.$this._currentlyUpdatingChildIndex = null;
      }
      _this.$this._childElements.remove$1(0, _this.index);
    },
    $signature: 0
  };
  (function aliases() {
    var _ = A.SliverLogicalParentData.prototype;
    _.super$SliverLogicalParentData$toString = _.toString$0;
    _ = A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin.prototype;
    _.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$attach = _.attach$1;
    _.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$detach = _.detach$0;
    _ = A.RenderSliverEdgeInsetsPadding.prototype;
    _.super$RenderSliverEdgeInsetsPadding$performLayout = _.performLayout$0;
    _ = A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin.prototype;
    _.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$attach = _.attach$1;
    _.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$detach = _.detach$0;
  })();
  (function installTearOffs() {
    var _instance = hunkHelpers.installInstanceTearOff,
      _instance_2_u = hunkHelpers._instance_2u,
      _instance_1_u = hunkHelpers._instance_1u,
      _static_2 = hunkHelpers._static_2,
      _instance_1_i = hunkHelpers._instance_1i;
    _instance(A.RenderSliver.prototype, "get$hitTest", 0, 1, null, ["call$3$crossAxisPosition$mainAxisPosition"], ["hitTest$3$crossAxisPosition$mainAxisPosition"], 2, 0, 0);
    var _;
    _instance_2_u(_ = A.RenderViewportBase.prototype, "get$_paintContents", "_paintContents$2", 3);
    _instance(_, "get$showOnScreen", 0, 0, null, ["call$4$curve$descendant$duration$rect", "call$0", "call$2$descendant$rect", "call$1$rect", "call$3$curve$duration$rect"], ["showOnScreen$4$curve$descendant$duration$rect", "showOnScreen$0", "showOnScreen$2$descendant$rect", "showOnScreen$1$rect", "showOnScreen$3$curve$duration$rect"], 4, 0, 0);
    _instance_1_u(A._AutomaticKeepAliveState.prototype, "get$_addClient", "_addClient$1", 5);
    _static_2(A, "sliver___kDefaultSemanticIndexCallback$closure", "_kDefaultSemanticIndexCallback", 7);
    _instance_1_i(_ = A._SelectionKeepAliveState.prototype, "get$add", "add$1", 1);
    _instance_1_i(_, "get$remove", "remove$1", 1);
    _instance_1_u(A.SliverMultiBoxAdaptorElement.prototype, "get$removeChild", "removeChild$1", 6);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _mixinHard = hunkHelpers.mixinHard,
      _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(A.RenderIndexedSemantics, B.RenderProxyBox);
    _inherit(A.SliverConstraints, B.Constraints);
    _inheritMany(B.Object, [A._SliverGeometry_Object_Diagnosticable, A.RenderSliverHelpers, A.KeepAliveParentDataMixin, A.RenderSliverWithKeepAliveMixin, A.SliverChildDelegate]);
    _inherit(A.SliverGeometry, A._SliverGeometry_Object_Diagnosticable);
    _inherit(A.SliverHitTestResult, B.HitTestResult);
    _inherit(A.SliverHitTestEntry, B.HitTestEntry);
    _inheritMany(B.ParentData, [A.SliverLogicalParentData, A.SliverPhysicalParentData]);
    _inherit(A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin, A.SliverPhysicalParentData);
    _inherit(A.SliverPhysicalContainerParentData, A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin);
    _inherit(A.RenderSliver, B.RenderObject);
    _inheritMany(B.Closure, [A.RenderSliverHelpers_hitTestBoxChild_closure, A.RenderSliverMultiBoxAdaptor__createOrObtainChild_closure, A.RenderSliverMultiBoxAdaptor_collectGarbage_closure, A.RenderSliverMultiBoxAdaptor_collectGarbage__closure, A.RenderViewportBase_visitChildrenForSemantics_closure, A.RenderViewportBase_hitTestChildren_closure, A._AutomaticKeepAliveState__addClient_closure, A._AutomaticKeepAliveState__getChildElement_closure, A.SliverMultiBoxAdaptorElement_performRebuild_processElement]);
    _inheritMany(A.RenderSliver, [A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin, A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin]);
    _inherit(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers, A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin);
    _inherit(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin, A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers);
    _inherit(A.RenderSliverMultiBoxAdaptor, A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin);
    _inherit(A.RenderSliverFixedExtentBoxAdaptor, A.RenderSliverMultiBoxAdaptor);
    _inherit(A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin, A.SliverLogicalParentData);
    _inherit(A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin, A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin);
    _inherit(A.SliverMultiBoxAdaptorParentData, A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin);
    _inherit(A.RenderSliverEdgeInsetsPadding, A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin);
    _inherit(A.CacheExtentStyle, B._Enum);
    _inherit(A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin, B.RenderBox);
    _inherit(A.RenderViewportBase, A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin);
    _inherit(A.RenderViewport, A.RenderViewportBase);
    _inheritMany(B.StatefulWidget, [A.AutomaticKeepAlive, A._SelectionKeepAlive]);
    _inheritMany(B.State, [A._AutomaticKeepAliveState, A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin]);
    _inheritMany(B.Closure0Args, [A._AutomaticKeepAliveState__createCallback_closure, A._AutomaticKeepAliveState__createCallback__closure, A._AutomaticKeepAliveState__createCallback__closure0, A._AutomaticKeepAliveState__createCallback___closure, A._SelectionKeepAliveState_listensTo_closure, A.SliverMultiBoxAdaptorElement_performRebuild_closure, A.SliverMultiBoxAdaptorElement_performRebuild_closure0, A.SliverMultiBoxAdaptorElement_createChild_closure, A.SliverMultiBoxAdaptorElement_removeChild_closure]);
    _inherit(A.IndexedSemantics, B.SingleChildRenderObjectWidget);
    _inherit(A.NeverScrollableScrollPhysics, B.ScrollPhysics);
    _inherit(A._SaltedValueKey, B.ValueKey);
    _inherit(A._SelectionKeepAliveState, A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin);
    _inherit(A.SliverWithKeepAliveWidget, B.RenderObjectWidget);
    _inherit(A.SliverMultiBoxAdaptorWidget, A.SliverWithKeepAliveWidget);
    _inherit(A.SliverMultiBoxAdaptorElement, B.RenderObjectElement);
    _inherit(A.KeepAlive, B.ParentDataWidget);
    _inherit(A.Viewport, B.MultiChildRenderObjectWidget);
    _inherit(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin, B.MultiChildRenderObjectElement);
    _inherit(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin, A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin);
    _inherit(A._ViewportElement, A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin);
    _mixin(A._SliverGeometry_Object_Diagnosticable, B.Diagnosticable);
    _mixinHard(A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin, B.ContainerParentDataMixin);
    _mixinHard(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin, B.ContainerRenderObjectMixin);
    _mixin(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers, A.RenderSliverHelpers);
    _mixin(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin, A.RenderSliverWithKeepAliveMixin);
    _mixinHard(A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin, B.ContainerParentDataMixin);
    _mixin(A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin, A.KeepAliveParentDataMixin);
    _mixinHard(A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin, B.RenderObjectWithChildMixin);
    _mixinHard(A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin, B.ContainerRenderObjectMixin);
    _mixinHard(A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin, B.AutomaticKeepAliveClientMixin);
    _mixin(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin, B.NotifiableElementMixin);
    _mixin(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin, D.ViewportElementMixin);
  })();
  B._Universe_addRules(init.typeUniverse, JSON.parse('{"RenderIndexedSemantics":{"RenderBox":[],"RenderObjectWithChildMixin":["RenderBox"],"RenderObject":[],"DiagnosticableTree":[],"AbstractNode":[],"HitTestTarget":[]},"SliverHitTestResult":{"HitTestResult":[]},"SliverPhysicalContainerParentData":{"SliverPhysicalParentData":[],"ContainerParentDataMixin":["RenderSliver"],"ParentData":[]},"SliverHitTestEntry":{"HitTestEntry":["RenderSliver"]},"SliverLogicalParentData":{"ParentData":[]},"SliverPhysicalParentData":{"ParentData":[]},"RenderSliver":{"RenderObject":[],"DiagnosticableTree":[],"AbstractNode":[],"HitTestTarget":[]},"RenderSliverFixedExtentBoxAdaptor":{"RenderSliverMultiBoxAdaptor":[],"RenderSliver":[],"ContainerRenderObjectMixin":["RenderBox","SliverMultiBoxAdaptorParentData"],"RenderObject":[],"DiagnosticableTree":[],"AbstractNode":[],"HitTestTarget":[]},"KeepAliveParentDataMixin":{"ParentData":[]},"SliverMultiBoxAdaptorParentData":{"SliverLogicalParentData":[],"ContainerParentDataMixin":["RenderBox"],"KeepAliveParentDataMixin":[],"ParentData":[]},"RenderSliverMultiBoxAdaptor":{"RenderSliver":[],"ContainerRenderObjectMixin":["RenderBox","SliverMultiBoxAdaptorParentData"],"RenderObject":[],"DiagnosticableTree":[],"AbstractNode":[],"HitTestTarget":[]},"RenderSliverEdgeInsetsPadding":{"RenderSliver":[],"RenderObjectWithChildMixin":["RenderSliver"],"RenderObject":[],"DiagnosticableTree":[],"AbstractNode":[],"HitTestTarget":[]},"CacheExtentStyle":{"Enum":[]},"RenderViewportBase":{"_RenderViewportBase_RenderBox_ContainerRenderObjectMixin":["1"],"RenderBox":[],"ContainerRenderObjectMixin":["RenderSliver","1"],"RenderAbstractViewport":[],"RenderObject":[],"DiagnosticableTree":[],"AbstractNode":[],"HitTestTarget":[]},"RenderViewport":{"_RenderViewportBase_RenderBox_ContainerRenderObjectMixin":["SliverPhysicalContainerParentData"],"RenderBox":[],"ContainerRenderObjectMixin":["RenderSliver","SliverPhysicalContainerParentData"],"RenderAbstractViewport":[],"RenderObject":[],"DiagnosticableTree":[],"AbstractNode":[],"HitTestTarget":[],"ContainerRenderObjectMixin.1":"SliverPhysicalContainerParentData","_RenderViewportBase_RenderBox_ContainerRenderObjectMixin.0":"SliverPhysicalContainerParentData","ContainerRenderObjectMixin.0":"RenderSliver"},"AutomaticKeepAlive":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_AutomaticKeepAliveState":{"State":["AutomaticKeepAlive"]},"IndexedSemantics":{"SingleChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"_SelectionKeepAlive":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_SaltedValueKey":{"ValueKey":["Key"],"LocalKey":[],"Key":[],"ValueKey.T":"Key"},"_SelectionKeepAliveState":{"State":["_SelectionKeepAlive"]},"SliverWithKeepAliveWidget":{"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverMultiBoxAdaptorWidget":{"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverMultiBoxAdaptorElement":{"RenderObjectElement":[],"Element0":[],"DiagnosticableTree":[],"BuildContext":[]},"KeepAlive":{"ParentDataWidget":["KeepAliveParentDataMixin"],"ProxyWidget":[],"Widget":[],"DiagnosticableTree":[],"ParentDataWidget.T":"KeepAliveParentDataMixin"},"Viewport":{"MultiChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"_ViewportElement":{"RenderObjectElement":[],"Element0":[],"DiagnosticableTree":[],"BuildContext":[]}}'));
  B._Universe_addErasedTypes(init.typeUniverse, JSON.parse('{"RenderViewportBase":1}'));
  var type$ = (function rtii() {
    var findType = B.findType;
    return {
      ClipRectLayer: findType("ClipRectLayer"),
      ContainerLayer: findType("ContainerLayer0"),
      Directionality: findType("Directionality"),
      Element: findType("Element0"),
      JSArray_DiagnosticsNode: findType("JSArray<DiagnosticsNode>"),
      JSArray_RenderSliver: findType("JSArray<RenderSliver>"),
      JSArray_String: findType("JSArray<String>"),
      KeepAliveParentDataMixin: findType("KeepAliveParentDataMixin"),
      Listenable: findType("Listenable"),
      NotificationListener_KeepAliveNotification: findType("NotificationListener<KeepAliveNotification>"),
      ParentDataWidget_KeepAliveParentDataMixin: findType("ParentDataWidget<KeepAliveParentDataMixin>"),
      RenderBox: findType("RenderBox"),
      RenderObject: findType("RenderObject"),
      RenderSliver: findType("RenderSliver"),
      RenderSliverMultiBoxAdaptor: findType("RenderSliverMultiBoxAdaptor"),
      RenderViewport: findType("RenderViewport"),
      Selectable: findType("Selectable"),
      SliverConstraints: findType("SliverConstraints"),
      SliverMultiBoxAdaptorParentData: findType("SliverMultiBoxAdaptorParentData"),
      SliverMultiBoxAdaptorWidget: findType("SliverMultiBoxAdaptorWidget"),
      SliverPhysicalParentData: findType("SliverPhysicalParentData"),
      Viewport: findType("Viewport"),
      double: findType("double"),
      int: findType("int"),
      nullable_Element: findType("Element0?"),
      nullable_ParentDataElement_KeepAliveParentDataMixin: findType("ParentDataElement<KeepAliveParentDataMixin>?"),
      nullable_RenderBox: findType("RenderBox?"),
      nullable_RenderSliver: findType("RenderSliver?"),
      nullable_SliverMultiBoxAdaptorParentData: findType("SliverMultiBoxAdaptorParentData?"),
      void_Function: findType("~()")
    };
  })();
  (function constants() {
    E.CacheExtentStyle_0 = new A.CacheExtentStyle(0, "pixel");
    E.CacheExtentStyle_1 = new A.CacheExtentStyle(1, "viewport");
    E.Offset_0_m1 = new B.Offset(0, -1);
    E.Offset_m1_0 = new B.Offset(-1, 0);
  })();
};

$__dart_deferred_initializers__["XY1P3sDEDhkAyxs5UipeQoEQNog="] = $__dart_deferred_initializers__.current
